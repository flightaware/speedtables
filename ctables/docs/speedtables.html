<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="824.44">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p2 {margin: 0.0px 0.0px 12.0px 18.0px; text-indent: -18.0px; font: 12.0px Helvetica; color: #005ca4}
    p.p3 {margin: 0.0px 0.0px 11.0px 0.0px; font: 24.0px Verdana; min-height: 29.0px}
    p.p4 {margin: 0.0px 0.0px 11.0px 18.0px; font: 16.0px Verdana; color: #005ca4}
    p.p5 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Helvetica}
    p.p6 {margin: 0.0px 0.0px 9.0px 18.0px; font: 12.0px Helvetica}
    p.p7 {margin: 0.0px 0.0px 5.0px 18.0px; font: 16.0px Verdana; color: #005ca4}
    p.p8 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Helvetica}
    p.p9 {margin: 0.0px 0.0px 12.0px 0.0px; font: 24.0px Verdana; min-height: 29.0px}
    p.p10 {margin: 0.0px 0.0px 12.0px 22.5px; text-indent: -9.0px; font: 12.0px Helvetica; color: #005ca4}
    p.p11 {margin: 0.0px 0.0px 12.0px 27.0px; text-indent: 9.0px; font: 12.0px Helvetica}
    p.p12 {margin: 0.0px 0.0px 12.0px 22.5px; font: 12.0px Helvetica}
    p.p13 {margin: 0.0px 0.0px 7.0px 22.5px; font: 12.0px Helvetica}
    p.p14 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Helvetica}
    p.p15 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p16 {margin: 0.0px 0.0px 11.0px 0.0px; text-align: right; font: 8.0px Helvetica; color: #005ca4}
    p.p17 {margin: 0.0px 0.0px 9.0px 0.0px; font: 12.0px Helvetica}
    p.p18 {margin: 0.0px 0.0px 10.0px 0.0px; font: 12.0px Helvetica}
    p.p19 {margin: 0.0px 0.0px 7.0px 0.0px; font: 14.0px Helvetica; color: #005ca4}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Helvetica}
    p.p21 {margin: 0.0px 0.0px 7.0px 0.0px; font: 10.0px Helvetica}
    p.p22 {margin: 0.0px 0.0px 7.0px 0.0px; text-align: right; font: 9.0px Helvetica; color: #005ca4}
    p.p23 {margin: 0.0px 0.0px 11.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p24 {margin: 0.0px 0.0px 14.0px 18.0px; font: 13.0px Verdana; color: #005ca4}
    p.p25 {margin: 0.0px 0.0px 1.0px 0.0px; font: 11.0px Courier}
    p.p26 {margin: 0.0px 0.0px 1.0px 0.0px; font: 11.0px Courier; min-height: 13.0px}
    p.p27 {margin: 0.0px 0.0px 7.0px 0.0px; font: 11.0px Courier}
    p.p28 {margin: 0.0px 0.0px 5.0px 18.0px; font: 12.0px Helvetica}
    p.p29 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Courier}
    p.p30 {margin: 0.0px 0.0px 1.0px 0.0px; font: 12.0px Courier}
    p.p31 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Courier New}
    p.p32 {margin: 0.0px 0.0px 2.0px 0.0px; font: 12.0px Courier}
    p.p33 {margin: 0.0px 0.0px 6.0px 0.0px; font: 10.0px Helvetica}
    p.p34 {margin: 0.0px 0.0px 7.0px 0.0px; text-align: right; font: 8.0px Helvetica; color: #005ca4}
    p.p35 {margin: 0.0px 0.0px 7.0px 0.0px; font: 10.0px Courier}
    p.p36 {margin: 0.0px 0.0px 9.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p37 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Courier; color: #005ca4}
    p.p38 {margin: 0.0px 0.0px 9.0px 0.0px; font: 12.0px Courier}
    p.p39 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; color: #005ca4}
    p.p40 {margin: 0.0px 0.0px 8.0px 0.0px; font: 12.0px Helvetica}
    p.p41 {margin: 0.0px 0.0px 11.0px 0.0px; font: 12.0px Helvetica}
    p.p42 {margin: 0.0px 0.0px 6.0px 18.0px; font: 12.0px Helvetica}
    p.p43 {margin: 0.0px 0.0px 9.0px 18.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p44 {margin: 0.0px 0.0px 2.0px 18.0px; font: 12.0px Helvetica}
    p.p45 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Courier}
    p.p46 {margin: 0.0px 0.0px 2.0px 18.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p47 {margin: 0.0px 0.0px 1.0px 0.0px; font: 12.0px Courier; min-height: 14.0px}
    p.p48 {margin: 0.0px 0.0px 2.0px 0.0px; font: 12.0px Courier; min-height: 14.0px}
    p.p49 {margin: 0.0px 0.0px 7.0px 0.0px; font: 12.0px Courier; min-height: 14.0px}
    p.p50 {margin: 0.0px 0.0px 1.0px 18.0px; font: 12.0px Helvetica}
    p.p51 {margin: 0.0px 0.0px 1.0px 0.0px; font: 10.0px Courier}
    p.p52 {margin: 0.0px 0.0px 9.0px 0.0px; font: 10.0px Courier}
    p.p53 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p54 {margin: 0.0px 0.0px 7.0px 0.0px; font: 24.0px Verdana; min-height: 29.0px}
    p.p55 {margin: 0.0px 0.0px 14.0px 18.0px; font: 13.0px Verdana; color: #005ca4; min-height: 16.0px}
    p.p56 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Courier; min-height: 14.0px}
    p.p57 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Courier New}
    p.p58 {margin: 0.0px 0.0px 2.0px 18.0px; font: 12.0px Courier New}
    p.p59 {margin: 0.0px 0.0px 1.0px 18.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p60 {margin: 0.0px 0.0px 7.0px 18.0px; font: 12.0px Courier; color: #005ca4}
    p.p61 {margin: 0.0px 0.0px 1.0px 0.0px; font: 8.0px Courier}
    p.p62 {margin: 0.0px 0.0px 1.0px 0.0px; font: 8.0px Courier; min-height: 10.0px}
    p.p63 {margin: 0.0px 0.0px 7.0px 0.0px; font: 8.0px Courier}
    p.p64 {margin: 0.0px 0.0px 7.0px 18.0px; font: 13.0px Verdana; color: #005ca4}
    p.p65 {margin: 0.0px 0.0px 1.0px 0.0px; font: 13.0px Verdana; color: #005ca4}
    p.p66 {margin: 0.0px 0.0px 7.0px 0.0px; font: 13.0px Helvetica}
    p.p67 {margin: 0.0px 0.0px 4.0px 0.0px; font: 12.0px Courier}
    p.p68 {margin: 0.0px 0.0px 7.0px 0.0px; font: 13.0px Verdana; color: #005ca4}
    p.p69 {margin: 0.0px 0.0px 0.0px 0.0px; font: 6.7px Helvetica}
    p.p70 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Verdana}
    span.s1 {letter-spacing: 0.0px}
    span.s2 {letter-spacing: 0.0px color: #000000}
    span.s3 {font: 72.0px Helvetica; letter-spacing: 0.0px color: #000000}
    span.s4 {font: 72.0px Helvetica; letter-spacing: 0.0px}
    span.s5 {vertical-align: 1.0px; letter-spacing: 0.0px}
    span.s6 {font: 8.0px Helvetica; letter-spacing: 0.0px}
    span.s7 {font: 12.0px Courier; letter-spacing: 0.0px}
    span.s8 {font: 12.0px Courier New; letter-spacing: 0.0px}
    span.s9 {font: 12.0px Helvetica; letter-spacing: 0.0px}
    span.s10 {font: 10.0px Helvetica; letter-spacing: 0.0px}
    span.s11 {font: 13.0px Verdana; letter-spacing: 0.0px color: #005ca4}
    span.s12 {font: 12.0px Courier; letter-spacing: 0.0px color: #005ca4}
    span.s13 {font: 12.0px Helvetica; letter-spacing: 0.0px color: #000000}
    span.s14 {letter-spacing: 0.0px color: #005ca4}
    span.s15 {letter-spacing: 0.0px color: #005ea5}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><br></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>speed tables - a high-performance, memory-resident database</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>1</span></p>
<p class="p3"><span class="s1"></span><br></p>
<p class="p4"><span class="s1">This chapter gives an overview of speed tables and describes the sort of applications they are useful for.</span></p>
<p class="p5"><span class="s1">Speed tables provides an interface for defining <i>tables</i> containing zero or more <i>rows</i>, with each row containing one or more <i>fields</i>.<span class="Apple-converted-space">Â  </span>The speed table compiler reads the table definition and generates C code to create and manage corresponding structures, currently producing a set of C access routines and a C language extension for Tcl to create, access and manipulate those tables.<span class="Apple-converted-space">Â  </span>It then compiles the extension, links it as a shared library, and makes it loadable on demand via Tcl's "package require" mechanism.</span></p>
<p class="p6"><span class="s1">Speed tables are well-suited for applications for which this table/row/field abstraction is useful, with row counts from the dozens to the tens of millions, for which the performance requirements for access or update frequency exceed those of the available SQL database, and the application does not require â€œno transaction lossâ€ behavior in the event of a crash.</span></p>
<p class="p7"><span class="s1">Example Application</span></p>
<p class="p5"><span class="s1">Speed Tables is used as a high-speed cache that front-ends a SQL database for a website generating millions of customized page views per day using commodity hardware.</span></p>
<p class="p5"><span class="s1">In contrast to ad-hoc tables implemented with some combination of <i>arrays</i>, <i>lists</i>, <i>upvar</i>, <i>namespaces</i>, or even using <i>dicts</i>, Speed tablesâ€™ memory footprint is far smaller and performance far higher when many rows are present.</span></p>
<p class="p5"><span class="s1">Speed tables support tab-separated reading and writing to files and TCP/IP sockets, and has a direct C interface to PostgreSQL.<span class="Apple-converted-space">Â  </span>Examples are provided for importing SQL query results into a speed table as well as copying from a speed table to a database table.<span class="Apple-converted-space">Â  </span>Speed tablesâ€™ search function provides a number of powerful capabilities including results sorting, setting offsets and limits, specifying match expressions, and counting.</span></p>
<p class="p1"><br></p>
<p class="p8"><span class="s1"><span class="Apple-tab-span">	</span>Contents<span class="Apple-tab-span">	</span></span><span class="s4"><span class="Apple-tab-span">	</span></span></p>
<p class="p9"><span class="s1"></span><br></p>
<p class="p10"><span class="s1">Representing Complex Data Structures in Tcl<span class="Apple-tab-span">	</span></span><span class="s5">4</span></p>
<p class="p10"><span class="s1">Speed Table Data Types<span class="Apple-tab-span">	</span></span><span class="s5">7</span></p>
<p class="p11"><span class="s1">indexed<span class="Apple-tab-span">	</span>8</span></p>
<p class="p11"><span class="s1">notnull<span class="Apple-tab-span">	</span>8</span></p>
<p class="p11"><span class="s1">default<span class="Apple-tab-span">	</span>8</span></p>
<p class="p11"><span class="s1">length<span class="Apple-tab-span">	</span>8</span></p>
<p class="p11"><span class="s1">unique<span class="Apple-tab-span">	</span>8</span></p>
<p class="p10"><span class="s1">Example Speed Table Definition<span class="Apple-tab-span">	</span></span><span class="s5">9</span></p>
<p class="p10"><span class="s1">Where Stuff Is Built<span class="Apple-tab-span">	</span></span><span class="s5">13</span></p>
<p class="p10"><span class="s1">Methods for Manipulating Speed Tables<span class="Apple-tab-span">	</span></span><span class="s5">14</span></p>
<p class="p11"><span class="s1">set<span class="Apple-tab-span">	</span>14</span></p>
<p class="p11"><span class="s1">store<span class="Apple-tab-span">	</span>15</span></p>
<p class="p11"><span class="s1">makekey<span class="Apple-tab-span">	</span>15</span></p>
<p class="p11"><span class="s1">key<span class="Apple-tab-span">	</span>15</span></p>
<p class="p11"><span class="s1">fields<span class="Apple-tab-span">	</span>15</span></p>
<p class="p11"><span class="s1">field<span class="Apple-tab-span">	</span>16</span></p>
<p class="p11"><span class="s1">get<span class="Apple-tab-span">	</span>16</span></p>
<p class="p11"><span class="s1">array_get<span class="Apple-tab-span">	</span>16</span></p>
<p class="p11"><span class="s1">array_get_with_nulls<span class="Apple-tab-span">	</span>16</span></p>
<p class="p11"><span class="s1">exists<span class="Apple-tab-span">	</span>17</span></p>
<p class="p11"><span class="s1">delete<span class="Apple-tab-span">	</span>17</span></p>
<p class="p11"><span class="s1">count<span class="Apple-tab-span">	</span>18</span></p>
<p class="p11"><span class="s1">batch<span class="Apple-tab-span">	</span>18</span></p>
<p class="p11"><span class="s1">search<span class="Apple-tab-span">	</span>18</span></p>
<p class="p11"><span class="s1">search+<span class="Apple-tab-span">	</span>24</span></p>
<p class="p11"><span class="s1">foreach<span class="Apple-tab-span">	</span>24</span></p>
<p class="p11"><span class="s1">incr<span class="Apple-tab-span">	</span>24</span></p>
<p class="p11"><span class="s1">type<span class="Apple-tab-span">	</span>25</span></p>
<p class="p11"><span class="s1">import_postgres_result<span class="Apple-tab-span">	</span>25</span></p>
<p class="p11"><span class="s1">fieldtype<span class="Apple-tab-span">	</span>26</span></p>
<p class="p11"><span class="s1">needs_quoting<span class="Apple-tab-span">	</span>26</span></p>
<p class="p11"><span class="s1">names<span class="Apple-tab-span">	</span>26</span></p>
<p class="p11"><span class="s1">reset<span class="Apple-tab-span">	</span>26</span></p>
<p class="p11"><span class="s1">destroy<span class="Apple-tab-span">	</span>27</span></p>
<p class="p11"><span class="s1">share<span class="Apple-tab-span">	</span>27</span></p>
<p class="p11"><span class="s1">getprop<span class="Apple-tab-span">	</span>27</span></p>
<p class="p11"><span class="s1">attach<span class="Apple-tab-span">	</span>27</span></p>
<p class="p11"><span class="s1">statistics<span class="Apple-tab-span">	</span>27</span></p>
<p class="p11"><span class="s1">write_tabsep<span class="Apple-tab-span">	</span>28</span></p>
<p class="p11"><span class="s1">read_tabsep<span class="Apple-tab-span">	</span>28</span></p>
<p class="p11"><span class="s1">index<span class="Apple-tab-span">	</span>29</span></p>
<p class="p10"><span class="s1">Special Notes On How To Make Searches Go Fast<span class="Apple-tab-span">	</span></span><span class="s5">31</span></p>
<p class="p10"><span class="s1">Client-Server Speed Tables<span class="Apple-tab-span">	</span></span><span class="s5">32</span></p>
<p class="p10"><span class="s1">Shared Memory Speed Tables<span class="Apple-tab-span">	</span></span><span class="s5">37</span></p>
<p class="p11"><span class="s1">$ctable create name master list<span class="Apple-tab-span">	</span>38</span></p>
<p class="p11"><span class="s1">$ctable create name reader list<span class="Apple-tab-span">	</span>38</span></p>
<p class="p11"><span class="s1">$ctable attach pid<span class="Apple-tab-span">	</span>39</span></p>
<p class="p11"><span class="s1">$ctable getprop<span class="Apple-tab-span">	</span>39</span></p>
<p class="p11"><span class="s1">$ctable getprop name ...<span class="Apple-tab-span">	</span>39</span></p>
<p class="p11"><span class="s1">share command [$ctable share] ?options?<span class="Apple-tab-span">	</span>39</span></p>
<p class="p11"><span class="s1">$ctable share command ?options?<span class="Apple-tab-span">	</span>39</span></p>
<p class="p10"><span class="s1">stapi - Speed Table API<span class="Apple-tab-span">	</span></span><span class="s5">42</span></p>
<p class="p10"><span class="s1">stDisplay - Display Functions for the WWW<span class="Apple-tab-span">	</span></span><span class="s5">51</span></p>
<p class="p10"><span class="s1">C Code Generated and C Routines Created<span class="Apple-tab-span">	</span></span><span class="s5">54</span></p>
<p class="p10"><span class="s1">Interfacing with Speed Tables From C<span class="Apple-tab-span">	</span></span><span class="s5">62</span></p>
<p class="p10"><span class="s1">Troubleshooting<span class="Apple-tab-span">	</span></span><span class="s5">63</span></p>
<p class="p10"><span class="s1">Examples<span class="Apple-tab-span">	</span></span><span class="s5">65</span></p>
<p class="p12"><span class="s1">Copy Speed Table Search Results to a Tab-Separated File<span class="Apple-tab-span">	</span>65</span></p>
<p class="p12"><span class="s1">Load a Speed Table using read_tabsep<span class="Apple-tab-span">	</span>65</span></p>
<p class="p13"><span class="s1">Using Copy In For Super Fast Speed Table-to-PostgreSQL Transfers<span class="Apple-tab-span">	</span>65</span></p>
<p class="p14"><span class="s1"></span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Representing Complex Data Structures in Tcl</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>2</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Representing Complex Data Structures in Tcl</span></p>
<p class="p4"><span class="s1">This chapter describes common approaches taken to represent complex data structures in Tcl, their costs and tradeoffs, and begins to describe some of Speed Tablesâ€™ capabilities.</span></p>
<p class="p14"><span class="s1">Tcl is not well-known for its ability to represent complex data structures.<span class="Apple-converted-space">Â  </span>Yes, it has <i>lists</i> and <i>associative arrays</i> and, in Tcl 8.5, <i>dicts</i>.<span class="Apple-converted-space">Â  </span>Yes, object-oriented extensions such as <i>Incr Tcl</i> provide ways to plug objects together to represent fairly complex data structures and yes, the <i>BLT toolkit</i>, among others, has provided certain more efficient ways to represent data (a vector data type, for instance) than available by default and, yes, you can abuse <i>upvar</i> and <i>namespaces</i> as part of expressing the structure of, and methods of access for, your data.</span></p>
<p class="p14"><span class="s1">There are, however, three typical problems with this approach:</span></p>
<p class="p14"><span class="s1">It is memory-inefficient. <span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">Tables implemented using Tcl objects use an order of magnitude more memory than native C. <span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">For example, an integer, stored as a Tcl object, has the integer value and all the overhead of a Tcl object, 24 bytes minimum, routinely more, and often way more.<span class="Apple-converted-space">Â  </span>When constructing Tcl lists, there is an overhead to making those lists, and the list structures themselves consume memory, sometimes a surprising amount as Tcl tries to avoid allocating memory on the fly by often allocating more than you need, and sometimes much more than you need. </span><span class="s6"><sup></sup></span></p>
<p class="p14"><span class="s1">Another drawback of Tcl arrays is that they store the field names (keys) along with each value, which is inherently necessary given their design but is yet another example of the inefficiency of this approach.</span></p>
<p class="p14"><span class="s1">It is computationally inefficient.</span></p>
<p class="p14"><span class="s1">Constructing, managing and manipulating complicated structures out of lists, arrays, etc, is quite processor-intensive when compared to, for instance, a hand-coded C-based approach exploiting pointers, C structs, and the like.</span></p>
<p class="p17"><span class="s1">It yields code that is clumsy and obtuse.</span></p>
<p class="p7"><span class="s1">Hackish construction of complex data structures sucks</span></p>
<p class="p5"><span class="s1">Using a combination of <i>upvar</i> and <i>namespaces</i> and <i>lists</i> and <i>arrays</i> to represent a complex structure yields relatively opaque and inflexible ways of expressing and manipulating that structure, twisting the code and typically replicating little pieces of weird structure access drivel strewn throughout the application, making the code hard to follow, teach, fix, enhance, and hand off.</span></p>
<p class="p14"><span class="s1"><b>Speed tables</b> reads a structure definition and emits C code to create and manipulate tables of rows of that structure.<span class="Apple-converted-space">Â  </span>We generate a full-fledged Tcl C extension that manages rows of fields as native C structs and emit subroutines for manipulating those rows in an efficient manner.</span></p>
<p class="p14"><span class="s1">Memory efficiency is high because we have low per-row storage overhead beyond the size of the struct itself, and fields are stored in native formats such as short integer, integer, float, double, bit, etc.</span></p>
<p class="p14"><span class="s1">Computational efficiency is high because we are reasonably clever about storing and fetching those values, particularly when populating from lines of tab-separated data as well as PostgreSQL database query results, inserting into them by reading rows from a Tcl channel containing tab-separated data, writing them tab-separated, locating them, updating them, and counting them, as well as importing and exporting by other means.</span></p>
<p class="p14"><span class="s1">Speed tables avoids executing Tcl code on a per row basis when a lot of rows need to be looked at.<span class="Apple-converted-space">Â  </span>In particular when bulk inserting and bulk processing via search, Tcl essentially configures an execution engine that can operate on millions of rows of data without the Tcl interpreterâ€™s per-row involvement except, perhaps, for example, executing scripted code only on the few rows that match your search criteria.</span></p>
<p class="p17"><span class="s1">Speed tables also maintains a "null value" bit per field, unless told not to, and provide an out-of-band way to distinguish between null values and non-null values, as is present in SQL databases... providing a ready bridge between those databases and speed tables.</span></p>
<p class="p7"><span class="s1">Example Application</span></p>
<p class="p5"><span class="s1">Speed tables is used as the realtime database for a monitoring system that polls millions of devices every few minutes.<span class="Apple-converted-space">Â  </span>Device status and performance data is kept in speed tables.<span class="Apple-converted-space">Â  </span>Information about the status of devices is continually â€œsweptâ€ to the SQL database at a sustainable rate. The loss of even a sizable number of scan results in the event of a crash is not a serious problem, as within a few minutes of starting up, the system will have obtained fresh data by newly polling the devices.</span></p>
<p class="p14"><span class="s1">Speed tables supports defining skip list-based indexes on one or more fields in a row, providing multi-hundred-fold speed improvements for many searches.<span class="Apple-converted-space">Â  </span>Fields that are not declared to be indexable do not have any code generated to check for the existence of indexes, etc, when they are changed, one of a number of optimizations performed to make speed tables fast.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Speed Table Data Types</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>3</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Speed Table Data Types</span></p>
<p class="p4"><span class="s1">This chapter explains the various data types that can be used to create fields in a speed table.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p18"><span class="s1">The following data types are available</span><span class="s6"><sup></sup></span><span class="s1">:</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>boolean</i> - a single 0/1 bit</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>varstring</i> - a variable-length string</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>fixedstring</i> - a fixed-length string</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>short</i> - a short integer</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>int</i> - a machine native integer</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>long</i> - a machine native long</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>wide</i> - a 64-bit wide integer (Tcl Wide)</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>float</i> - a floating point number</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>double</i> - a double-precision floating point number</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>char</i> - a single character (deprecation likely)</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>mac - an ethernet MAC address</span></p>
<p class="p18"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>inet</i> - an internet IP address</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span><i>tclobj</i> - a Tcl object... more on this powerful capability later</span></p>
<p class="p14"><span class="s1">Fields are defined by the data type followed by the field name, for example...</span></p>
<p class="p14"><span class="s1">double longitude</span></p>
<p class="p14"><span class="s1">...to define a double-precision field named longitude.</span></p>
<p class="p14"><span class="s1">Field definitions can followed by one or more key-value pairs that define additional attributes about the field.<span class="Apple-converted-space">Â  </span>Supported attributes include</span></p>
<p class="p19"><span class="s1"><i>indexed<span class="Apple-converted-space">Â </span></i></span></p>
<p class="p14"><span class="s1">If indexed is specified with a true (nonzero) value, the code generated for the speed table will include support for generating, maintaining, and using a skip list index on the field being defined.</span></p>
<p class="p14"><span class="s1">Indexed traversal can be performed in conjunction with the speed tableâ€™s search functions to accelerate searches and avoid sorts.<span class="Apple-converted-space">Â  </span>Defaults to â€œindexed 0â€ aka the field is not generated with index support.</span></p>
<p class="p14"><span class="s1">Indexed support is not provided for boolean fields.</span></p>
<p class="p19"><span class="s1"><i>notnull</i></span></p>
<p class="p14"><span class="s1">If notnull is specified with a true (nonzero) value, the code generated for the speed table will have code for maintaining an out-of-band null/not-null status suppressed, resulting in a substantial performance increase for fields for which out-of-band null support is not needed.<span class="Apple-converted-space">Â  </span>Defaults to â€œnotnull 0â€ aka null values are supported.</span></p>
<p class="p19"><span class="s1"><i>default</i></span></p>
<p class="p14"><span class="s1">If default is specified, the following value is defined as the default value and will be set into rows that are created when the field does not have a value assigned.</span></p>
<p class="p14"><span class="s1">There is no default default value, however if no default value is defined and the field is declared as notnull, strings will default to empty and numbers will default to zero.</span></p>
<p class="p19"><span class="s1"><i>length</i></span></p>
<p class="p14"><span class="s1">Currently only valid for fixedstring fields, length specifies the length of the field in bytes.<span class="Apple-converted-space">Â  </span>There is no default length; length must be specified for fixedstring fields.</span></p>
<p class="p19"><span class="s1"><i>unique</i></span></p>
<p class="p14"><span class="s1">If unique is specified with a true value, the field is defined as indexed ,and an index has been created and is in existence for this field for the current table, a unique check will be performed on this field upon insertion into the speed table.</span></p>
<p class="p20"><span class="s1"><b><i>Bug: Unique checks are not currently being performed as of 12/31/06.</i></b></span></p>
<p class="p21"><span class="s1"><b><i>Bug: String search matching functions donâ€™t yet work for fixedstrings and fixedstrings have not had a lot of use as of 12/31/06.</i></b></span></p>
<p class="p5"><span class="s1"></span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>An Example Speed Table Definition</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>4</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p22"><span class="s1">Example Speed Table Definition</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p4"><span class="s1">This chapter provides an example speed table definition, explains it, and shows some basic usage of a speed table.</span></p>
<p class="p24"><span class="s1">Example Speed Table Definition</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">package require speedtable</span></p>
<p class="p26"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">CExtension animinfo 1.1 {</span></p>
<p class="p26"><span class="s1"></span><br></p>
<p class="p25"><span class="s1">SpeedTable animation_characters {</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>varstring name indexed 1 unique 0</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>varstring home</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>varstring show indexed 1 unique 0</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>varstring dad</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>boolean alive default 1</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>varstring gender default male</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int age</span></p>
<p class="p25"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int coolness</span></p>
<p class="p25"><span class="s1">}</span></p>
<p class="p26"><span class="s1"></span><br></p>
<p class="p27"><span class="s1">}</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p28"><span class="s1">Speed tables are defined inside the code block of the <i>CExtension</i>. <span class="Apple-converted-space">Â </span></span></p>
<p class="p28"><span class="s1">Executing this will generate table-specific C functions a Tcl C language extension named <i>Animinfo</i>, compile it and link it it into a shared library. <span class="Apple-converted-space">Â </span></span></p>
<p class="p28"><span class="s1">Multiple speed tables can be defined in one CExtension definition.</span></p>
<p class="p5"><span class="s1">No matter how you capitalize it, the package name with be the first character of your C extension name capitalized and the rest mapped to lowercase.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">The name of the C extension follows the CExtension keyword, followed by a version number, and then a code body containing table definitions.</span></p>
<p class="p24"><span class="s1">Loading Your Speed Table-Generated C Extension</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">After sourcing in the above definition, you can do a </span><span class="s7">package require Animinfo</span><span class="s1"> or </span><span class="s7">package require Animinfo 1.1</span><span class="s1"> and Tcl will load the extension and make it available.</span></p>
<p class="p14"><span class="s1">For efficiency's sake, we detect whether or not the C extension has been altered since the last time it was generated as a shared library, and avoid the compilation and linking phase when it isn't necessary.</span></p>
<p class="p14"><span class="s1">Sourcing the above code body and doing a </span><span class="s7">package require Animinfo</span><span class="s1"> will create one new command,<i> animation_characters</i>, corresponding to the defined table. We call this command a <i>meta table</i> or a <i>creator table</i>.</span></p>
<p class="p17"><span class="s7">animation_characters create t</span><span class="s1"> creates a new object, <b>t</b>, that is a Tcl command that will manage and manipulate zero or more rows of the <i>animation_characters</i> table.</span></p>
<p class="p7"><span class="s1">One meta table can create many speed tables</span></p>
<p class="p5"><span class="s1">You can create additional instances of the table using the meta table's <i>create</i> method.<span class="Apple-converted-space">Â  </span>All tables created from the same meta table operate independently of each other, although they share the meta table data structure that speed table implementation code uses to understand and operate on the tables.</span></p>
<p class="p14"><span class="s1">You can also say...</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â Â  Â  </span>set obj [animation_characters create #auto]</span></p>
<p class="p14"><span class="s1">...to create a new instance of the table (containing, at first, zero rows), without having to generate a unique name for it.</span></p>
<p class="p24"><span class="s1">Speed Table Basic Usage Examples</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">t set shake name "Master Shake" \</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>show â€œAqua Teen Hunger Forceâ€</span></p>
<p class="p14"><span class="s1">This creates a new row in the speed table named <b>t</b>.<span class="Apple-converted-space">Â  </span>Currently all rows in a speed table must have unique key value, which resides outside of the table definition itself.<span class="Apple-converted-space">Â  </span>The key for this row is â€œshakeâ€.</span><span class="s6"><sup></sup></span><span class="s1"><span class="Apple-converted-space">Â  </span>The name and show fields in the row are set to the passed-in values.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">We can set other fields in the same row:</span></p>
<p class="p29"><span class="s1">t set shake age 4 coolness -5</span></p>
<p class="p14"><span class="s1">And increment them in one operation:</span></p>
<p class="p30"><span class="s1">% t incr shake age 1 coolness -1</span></p>
<p class="p31"><span class="s1"><b>5 -6</b></span></p>
<p class="p14"><span class="s1">I can fetch a single value pretty naturally...</span></p>
<p class="p29"><span class="s1">if {[t get $key age] &gt; 18} {...}</span></p>
<p class="p14"><span class="s1">Or I can get all the fields in definition order:</span></p>
<p class="p30"><span class="s1">puts [t get shake]</span></p>
<p class="p31"><span class="s1"><b>{} {} {} {} {} 1 male 5 -6</b></span></p>
<p class="p14"><span class="s1">Forgot what fields are available?</span></p>
<p class="p30"><span class="s1">% t fields</span></p>
<p class="p31"><span class="s1"><b>id name home show dad alive gender age coolness</b></span></p>
<p class="p14"><span class="s1">You can get a list of fields in array get format:</span></p>
<p class="p30"><span class="s1">array set data [t array_get shake]</span></p>
<p class="p29"><span class="s1">puts â€œ$data(name) $data(coolness)â€</span></p>
<p class="p14"><span class="s1">In the above example, if a fieldâ€™s value is null then the field name and value will not be returned by <i>array_get</i>.<span class="Apple-converted-space">Â  </span>So if a field can be null, youâ€™ll want to check for its existence using <i>array_get_with_nulls</i>, which will always provide all the fieldsâ€™ values, substituting a settable null value (typically the empty string) when the value is null.</span></p>
<p class="p14"><span class="s1">Want to see if something exists?</span></p>
<p class="p30"><span class="s1">t exists frylock</span></p>
<p class="p31"><span class="s1"><b>0</b></span></p>
<p class="p14"><span class="s1">Letâ€™s load up our table from a file tab-separated data:</span></p>
<p class="p29"><span class="s1">set fp [open animation_characters.tsv]</span></p>
<p class="p29"><span class="s1">t read_tabsep $fp</span></p>
<p class="p29"><span class="s1">close $fp</span></p>
<p class="p24"><span class="s1">Search</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">Search is one of the most useful capabilities of speed tables.<span class="Apple-converted-space">Â  </span>Letâ€™s use search to write all of the rows in the table to a save file:</span></p>
<p class="p30"><span class="s1">set fp [open save.tsv]</span></p>
<p class="p30"><span class="s1">t search -write_tabsep $fp</span></p>
<p class="p29"><span class="s1">close $fp</span></p>
<p class="p14"><span class="s1">Want to restrict the results to a certain set of fields?<span class="Apple-converted-space">Â  </span>Use the </span><span class="s7">-fields</span><span class="s1"> option followed by a list of the names of the fields you want.</span></p>
<p class="p30"><span class="s1">t search -write_tabsep $fp \</span></p>
<p class="p29"><span class="s1">-fields {name show coolness}</span></p>
<p class="p14"><span class="s1">Sometimes you might want to include the names of the fields as the first line...</span></p>
<p class="p30"><span class="s1">t search -write_tabsep $fp \</span></p>
<p class="p30"><span class="s1">-fields {name show coolness} \</span></p>
<p class="p29"><span class="s1">-with_field_names 1</span></p>
<p class="p14"><span class="s1">Letâ€™s find everyone whoâ€™s on the Venture Brothers show whoâ€™s over 20 years old, and execute code for each result:</span></p>
<p class="p30"><span class="s1">t search -compare {{= show â€œVenture Brothers} {&gt; age 20}} \ -array_get data -code {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts $data</span></p>
<p class="p32"><span class="s1">}</span></p>
<p class="p24"><span class="s1">Additional meta table methods</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1"><i>animation_characters info</i> - which currently does nothing (boring)</span></p>
<p class="p14"><span class="s1"><i>animation_characters null_value \\N</i> - which sets the default null value for all tables of this table type to, in this case, \N<span class="Apple-converted-space">Â  </span>(<i>Hey, didnâ€™t you just get done saying the tables are independent of each other?</i><span class="Apple-converted-space">Â  </span>Well... yeah, I did.<span class="Apple-converted-space">Â  </span>Weâ€™re going to make it settable on a per-table basis, too, and that may have been done already -- itâ€™s pretty easy to add.)</span></p>
<p class="p14"><span class="s1"><i>animation_characters method foo bar</i> - this will register a new method named <i>foo</i> and then invoke the proc <i>bar</i> with the arguments being the name of the object followed by whatever arguments were passed.</span></p>
<p class="p14"><span class="s1">For example, if after executing </span><span class="s7">animation_characters method foo bar</span><span class="s1"> and creating an instance of the <i>animation_characters</i> table named <b>t</b>, if you executed</span></p>
<p class="p29"><span class="s1"><span class="Apple-tab-span">	</span> <span class="Apple-converted-space">Â  Â  </span>t foo a b c d</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>...then proc <i>bar</i> would be called with the arguments "<i>x a b c d</i>".</span></p>
<p class="p33"><span class="s1"><b><i>BUG - Tcl appears to examine a shared library name and stop at the first numeric digit in an apparently somewhat inadequate attempt to make sure it doesn't include shared library version numbers in the expected *_Init and*_SafeInit function names for the library being generated.<span class="Apple-converted-space">Â  </span>Consequently when you're defining a C extension via the CExtension command, do not include any digits in your C extension's name.</i></b></span></p>
<p class="p34"><span class="s1">Where Stuff Is Built</span></p>
<p class="p14"><span class="s1">The generated C source code, some copied .c and .h files, the compiled .o object file, and shared library are written in a directory called </span><span class="s8"><b>build</b></span><span class="s1"> underneath the directory that's current at the time the CExtension is sourced, unless a build path is specified.<span class="Apple-converted-space">Â  </span>For example, after the "package require speed table" and outside of and prior to the CExtension definition, if you invoke</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Speed TableBuildPath /tmp</span></p>
<p class="p14"><span class="s1">...then those files will be generated in the </span><span class="s8"><b>/tmp</b></span><span class="s1"> directory.<span class="Apple-converted-space">Â  </span>(It's a bad idea to use </span><span class="s8"><b>/tmp</b></span><span class="s1"> on a multiuser machine, of course, but could be OK for a dedicated appliance or something like that.)</span></p>
<p class="p14"><span class="s1">Note that the specified build path is appended to the Tcl library search path variable, <i>auto_path</i>, if it isn't already in there.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Methods for Manipulating Speed Tables</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>5</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Methods for Manipulating Speed Tables</span></p>
<p class="p4"><span class="s1">This chapter enumerates all of the defined methods that are available to interact with Speed Tables, with examples.</span></p>
<p class="p14"><span class="s1">Now the nitty gritty...<span class="Apple-converted-space">Â  </span>The following built-in methods are available as arguments to each instance of a speed table:</span></p>
<p class="p14"><span class="s1"><i>get</i>, <i>set</i>, <i>array_get</i>, <i>array_get_with_nulls</i>, <i>exists</i>, <i>delete</i>, <i>count</i>, <i>foreach</i>, <i>type</i>, <i>import</i>, <i>import_postgres_result</i>, <i>export</i>, <i>fields</i>, <i>fieldtype</i>, <i>needs_quoting</i>, <i>names</i>, <i>reset</i>, <i>destroy</i>, <i>statistics</i>, <i>write_tabsep</i>, <i>read_tabsep, key, makekey, store, share, getprop, attach</i></span></p>
<p class="p14"><span class="s1">For the examples, assume we have done a "</span><span class="s7">cable_info create x</span><span class="s1">"</span></p>
<p class="p19"><span class="s1"><i>set</i></span></p>
<p class="p29"><span class="s1">x set key ?-nocomplain? field value ?field value...?</span></p>
<p class="p14"><span class="s1">or</span></p>
<p class="p29"><span class="s1">x set key ?-nocomplain? keyValueList<span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">The key is required and it must be unique.<span class="Apple-converted-space">Â  </span>It can contain anything you want.<span class="Apple-converted-space">Â  </span>It's not also an element of the table.</span></p>
<p class="p5"><span class="s1">We may change this in the future to make it possible to have tables that do not require any keys (there is already a provision for this, though incomplete) and also to allow more than one key.<span class="Apple-converted-space">Â  </span>But for now, lame or not, this is how it works, and as Peter says, for more than one key, you can always create some kind of compound key.</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  </span>% </span><span class="s1">x set peter ip 127.0.0.1 name "Peter da Silva" i 501</span><span class="s9"><span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">In the above example, we create a row in the <b>cable_info</b> table named "x" with an index of "peter", an ip value of 127.0.0.1, a name of "Peter da Silva", and an "i" value of 501.<span class="Apple-converted-space">Â  </span>All fields in the row that have not been set will be marked as null.<span class="Apple-converted-space">Â  </span>(Also any field set with the null value will also be marked as null.)</span></p>
<p class="p35"><span class="s10">% </span><span class="s1">set values [list ip 127.0.0.1 name "Peter da Silva" i 501]</span></p>
<p class="p35"><span class="s10">% </span><span class="s1">x set peter $values</span></p>
<p class="p14"><span class="s1">In this example, we specify the value as a list of key-value pairs.<span class="Apple-converted-space">Â  </span>This is a natural way to pull an array into a speed table row:</span></p>
<p class="p35"><span class="s10">% </span><span class="s1">x set key [array get dataArray]</span></p>
<p class="p14"><span class="s1">By default it is an error to attempt to set a field in a row that does not exist.<span class="Apple-converted-space">Â  </span>However, if </span><span class="s7">-nocomplain</span><span class="s1"> is specified as the first argument, such errors are suppressed, hence all matching fields are set and any keys that do not exist in the table are silently ignored.<span class="Apple-converted-space">Â  </span>This is useful when an array contains some fields that you want to store in a speedtable row but may contain additional fields that you do not want to store but which, without </span><span class="s7">-nocomplain</span><span class="s1">, youâ€™d have to remove from the array prior to invoking </span><span class="s7">set</span><span class="s1">.</span></p>
<p class="p19"><span class="s1"><i>store</i></span></p>
<p class="p35"><span class="s1">x store ?-nocomplain? field value ?field valueâ€¦?</span></p>
<p class="p14"><span class="s1">or</span></p>
<p class="p35"><span class="s1">x store ?-nocomplain? keyValueList</span></p>
<p class="p14"><span class="s1">Store is similar to â€œsetâ€, but extracts the key from the provided fields. If the table does not have a field explicitly designated as a key, then the pseudo-field â€œ_keyâ€ is used. If the key is not present in the list, then the next autogenerated value (see read_tabsep) will be used.</span></p>
<p class="p14"><span class="s1">Store returns the key used to store the list.</span></p>
<p class="p19"><span class="s1"><i>makekey</i></span></p>
<p class="p35"><span class="s1">x makekey field value ?field valueâ€¦?</span></p>
<p class="p14"><span class="s1">or</span></p>
<p class="p35"><span class="s1">x makekey keyValueList</span></p>
<p class="p14"><span class="s1">This simply calculates what the appropriate key value for the list would be.</span></p>
<p class="p14"><span class="s1">For example, for a table where the field â€œipâ€ was a key:</span></p>
<p class="p35"><span class="s1">x makekey {ip 10.2.3.1 name host1}</span></p>
<p class="p14"><span class="s1">would return â€œ10.2.3.1â€</span></p>
<p class="p19"><span class="s1"><i>key</i></span></p>
<p class="p14"><span class="s1">Returns the name of the key field specified for the table, or â€œ_keyâ€ if none were specified.</span></p>
<p class="p19"><span class="s1"><i>fields</i></span></p>
<p class="p14"><span class="s1">"fields" returns a list of defined fields, in the order they were defined.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x fields</span></p>
<p class="p31"><span class="s1"><b>ip mac name address addressNumber geos i j ij</b></span></p>
<p class="p19"><span class="s1"><i>field</i></span></p>
<p class="p14"><span class="s1">"field" returns information about the values that defined the field.<span class="Apple-converted-space">Â  </span>You can use this command to retrieve all the key-value pairs that define a field.</span></p>
<p class="p14"><span class="s1">Since we accept (and ignore) arguments to field definitions for keys we donâ€™t recognize, you can define your own key-value pairs in field definitions inside of speed table definitions and access them using this method.</span></p>
<p class="p14"><span class="s1">Following the name of the field should be one of the keywords</span><span class="s7"> getprop</span><span class="s1">, </span><span class="s7">properties</span><span class="s1">, or </span><span class="s7">proplist</span><span class="s1">.<span class="Apple-converted-space">Â  </span></span><span class="s7">Properties</span><span class="s1"> will return the names of all of the properties as a Tcl list.<span class="Apple-converted-space">Â  </span></span><span class="s7">Proplist</span><span class="s1"> will return the names and values of all the properties as a Tcl list, in what we would call â€œarray setâ€ format.<span class="Apple-converted-space">Â  </span></span><span class="s7">Getprop</span><span class="s1"> will return the value associated with the key passed as an argument.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">$ctable field $fieldName proplist</span></p>
<p class="p31"><span class="s1"><b>default 1 name alive type boolean</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">$ctable field $fieldName properties</span></p>
<p class="p31"><span class="s1"><b>default name type</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">$ctable field $fieldName getprop default</span></p>
<p class="p19"><span class="s1"><i>get</i></span></p>
<p class="p14"><span class="s1">Get fields.<span class="Apple-converted-space">Â  </span>Get specified fields, or all fields if none are specified, returning them as a Tcl list.</span></p>
<p class="p29"><span class="s9">%</span><span class="s1"> x get peter</span></p>
<p class="p31"><span class="s1"><b>127.0.0.1 {} {Peter da Silva} {} {} {} 501 {} {}</b></span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p29"><span class="s9">% </span><span class="s1">x get peter ip name</span></p>
<p class="p31"><span class="s1"><b>127.0.0.1 {Peter da Silva}</b></span></p>
<p class="p19"><span class="s1"><i>array_get</i></span></p>
<p class="p14"><span class="s1">Get specified fields, or all fields if none are specified, in "array get" (key-value pair) format.<span class="Apple-converted-space">Â  </span>Note that if a field is null, it will not be fetched.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get peter</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 name {Peter da Silva} i 501</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get peter ip name mac</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 name {Peter da Silva}</b></span></p>
<p class="p19"><span class="s1"><i>array_get_with_nulls</i></span></p>
<p class="p14"><span class="s1">Get specified fields, or all fields if none are specified, in "array get" (key-value pair) format.<span class="Apple-converted-space">Â  </span>If a field contains the null value, it is fetched anyway.<span class="Apple-converted-space">Â  </span>(Yes this should probably be an option switch to array_get instead of its own method.)</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get_with_nulls peter</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 mac {} name {Peter da Silva} address {} addressNumber {} geos {} i 501 j {} ij {}</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get_with_nulls peter ip name mac</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 name {Peter da Silva} mac {}</b></span></p>
<p class="p14"><span class="s1">Note that if the null value has been set, that value will be returned other than the default null value of an empty Tcl object.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">cable_info null_value \\N</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get_with_nulls peter</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 mac \N name {Peter da Silva} address \N addressNumber \N geos \N i 501 j \N ij \N</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x array_get_with_nulls peter ip name mac</span></p>
<p class="p31"><span class="s1"><b>ip 127.0.0.1 name {Peter da Silva} mac \N</b></span></p>
<p class="p19"><span class="s1"><i>exists</i></span></p>
<p class="p14"><span class="s1">Return 1 if the specified key exists, 0 otherwise.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x exists peter</span></p>
<p class="p31"><span class="s1"><b>1</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x exists karl</span></p>
<p class="p31"><span class="s1"><b>0</b></span></p>
<p class="p19"><span class="s1"><i>delete</i></span></p>
<p class="p14"><span class="s1">Delete the specified row from the table.<span class="Apple-converted-space">Â  </span>Returns 1 if the row existed, 0 if it did not.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x delete karl</span></p>
<p class="p31"><span class="s1"><b>0</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x set karl</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x delete karl</span></p>
<p class="p31"><span class="s1"><b>1</b></span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x delete karl</span></p>
<p class="p31"><span class="s1"><b>0</b></span></p>
<p class="p19"><span class="s1"><i>count</i></span></p>
<p class="p14"><span class="s1">Return a count the number of rows in the table.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x count</span></p>
<p class="p31"><span class="s1"><b>1</b></span></p>
<p class="p19"><span class="s1"><i>batch</i></span></p>
<p class="p14"><span class="s1">Take a list of speed table commands (minus the table name, as thatâ€™s implicit), and invoke each element of the list as a method invocation on the current speed table.</span></p>
<p class="p14"><span class="s1">A result list is constructed.</span></p>
<p class="p14"><span class="s1">As each command within the batch is invoked, if the invocation is successful and no value is returned, nothing is added to the result list.</span></p>
<p class="p14"><span class="s1">If the invocation is successful and a value is returned, a list is added to the result list containing two elements: the number of the element of the batch list and a sublist containing the Tcl result code (0) and whatever the result was that was returned.</span></p>
<p class="p14"><span class="s1">If the invocation failed, a list is added to the result list, containing the element index, as above, but with the Tcl result code set to TCL_ERROR (1) and the result portion is the error message returned.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x batch {{set dean age 17} {incr dean age 1} {incr brock age foo}}</span></p>
<p class="p31"><span class="s1"><b>{{1 {0 18}} {2 {1 {expected integer but got â€œfooâ€ while converting age increment amount while processing key-value list}}}</b></span></p>
<p class="p14"><span class="s1">In this example, setting Deanâ€™s age to 17 produced no result.<span class="Apple-converted-space">Â  </span>Incrementing it returned the incremented value (18), and trying to set Brockâ€™s age to a non-integer value recorded an error.</span></p>
<p class="p14"><span class="s1">Note that errors in batched commands do not cause batch to return an error.<span class="Apple-converted-space">Â  </span>It is up to the caller to examine the result of the batch command to see what happened.</span></p>
<p class="p14"><span class="s1">â€œbatchâ€ will return an error in the event of bad arguments passed to it, the batch list being unparseable as a list, etc.</span></p>
<p class="p19"><span class="s1"><i>search</i></span></p>
<p class="p14"><span class="s1">Search for matching rows and take actions on them, with optional sorting. Search exploits indexes on fields when available, or performs a brute force search if there are no indexed fields available in the compare list. These indexes are implemented using skip lists.</span></p>
<p class="p36"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">Brute-Force Search Is Brutally Fast</span></p>
<p class="p28"><span class="s1">Search can perform brute-force multivariable searches on a speed table and take actions on matching records, without any scripting code running on an every-row basis.</span></p>
<p class="p28"><span class="s1">On a modern 2006 Intel and AMD machines, speed table search can perform, for example, unanchored string match searches at a rate of sixteen million rows per CPU second (around 60 nanoseconds per row).</span></p>
<p class="p28"><span class="s1">On the other hand, skip lists point to a future where there isn't any key thatâ€™s external to the row -- that is, what would have been the external key would exist as a normal field in the row.</span></p>
<p class="p5"><span class="s1">Whether you should use indexes (skiplists) or not depends on the characteristics of the table. On one of our test systems, inserting a row into the table takes about 2.3 microseconds, but a single index increases this to about 7 microseconds. On the other hand, an indexed search on that field may be O(logN) on the number of rows in the table.</span></p>
<p class="p14"><span class="s1">Search is a powerful element of the speed tables tool that can be leveraged to do a number of the things traditionally done with database systems that incur much more overhead.</span></p>
<p class="p29"><span class="s1">$speedtable search ?-sort {?-?field..}? ?-fields fieldList? ?-glob pattern? ?-regexp pattern? ?-compare list? ?-countOnly 0|1? ?-offset offset? ?-limit limit? ?-code codeBody? ?-write_tabsep channel? ?-key keyVar? ?-get varName? ?-array_get varName? ?-array_get_with_nulls varName? ?-with_field_names 0|1?</span></p>
<p class="p37"><span class="s1">-sort sortArg</span></p>
<p class="p14"><span class="s1">Sort results based on the specified field or fields.<span class="Apple-converted-space">Â  </span>If multiple fields are specified, their precedence is in descending order.<span class="Apple-converted-space">Â  </span>In other words, the first field is the primary search key.</span></p>
<p class="p14"><span class="s1">If you want to sort a field in descending order, put a dash in front of the field name.</span></p>
<p class="p21"><span class="s1"><b><i>Bug: Speed tables are currently hard-coded to sort null values â€œhighâ€.<span class="Apple-converted-space">Â  </span>As this is not always what one wants, an ability to specify whether nulls are to sort high or low will likely be added in the future.</i></b></span></p>
<p class="p37"><span class="s1">-fields fieldList</span></p>
<p class="p14"><span class="s1">Restrict search results to the specified fields.</span></p>
<p class="p28"><span class="s1">If you have a lot of fields in your table and only need a few, using -fields to restrict retrieval to the specified fields will provide a nice performance boost.</span></p>
<p class="p5"><span class="s1">Fields that are used for sorting and/or for comparison expressions do not need to be included in -fields in order to be examined.</span></p>
<p class="p37"><span class="s1">-glob pattern</span></p>
<p class="p14"><span class="s1">Perform a glob-style comparison on the key, excluding the examination of rows not matching.</span></p>
<p class="p37"><span class="s1">-regexp pattern</span></p>
<p class="p14"><span class="s1">Not currently implemented.</span></p>
<p class="p37"><span class="s1">-countOnly 0|1</span></p>
<p class="p14"><span class="s1">If 1, counts matching rows but does not take any action based on the count.</span></p>
<p class="p37"><span class="s1">-offset offset</span></p>
<p class="p14"><span class="s1">If specified, begins actions on search results at the "offset" row found.<span class="Apple-converted-space">Â  </span>For example, if offset is 100, the first 100 matching records are bypassed before the search action begins to be taken on matching rows.</span></p>
<p class="p37"><span class="s1">-limit limit</span></p>
<p class="p14"><span class="s1">If specified, limits the number of rows matched to "limit".</span></p>
<p class="p14"><span class="s1">Even if used with -countOnly, -limit still works, so if, for example, you want to know if there are at least 10 matching records in the table but you don't care what they contain or if there are more than that many, you can search with -countOnly 1 -limit 10 and it will return 10 if there are ten or more matching rows.</span></p>
<p class="p37"><span class="s1">-write_tabsep channel</span></p>
<p class="p14"><span class="s1">Matching rows are written tab-separated to the file or socket (or postgresql database handle) "channel".</span></p>
<p class="p37"><span class="s1">-tab string</span></p>
<p class="p14"><span class="s1">Specify the separator string for write_tabsep (default â€œ\tâ€).</span></p>
<p class="p37"><span class="s1">-with_field_names 1</span></p>
<p class="p14"><span class="s1">If you are doing -write_tabsep, </span><span class="s7">-with_field_names 1</span><span class="s1"> will cause the first line emitted to be a tab-separated list of field names.</span></p>
<p class="p37"><span class="s1">-key keyVar</span></p>
<p class="p37"><span class="s1">-get listVar</span></p>
<p class="p37"><span class="s1">-array arrayName</span></p>
<p class="p37"><span class="s1">-array_with_nulls arrayName</span></p>
<p class="p37"><span class="s1">-array_get listVar</span></p>
<p class="p37"><span class="s1">-array_get_with_nulls listVar</span></p>
<p class="p37"><span class="s1">-code codeBody</span></p>
<p class="p14"><span class="s1">Run scripting code on matching rows.</span></p>
<p class="p14"><span class="s1">If </span><span class="s7">-key</span><span class="s1"> is specified, the key value of each matching row is written into the variable specified as the argument that follows it.</span></p>
<p class="p14"><span class="s1">If </span><span class="s7">-get</span><span class="s1"> is specified, the fields of the matching row are written into the variable specified as the argument to -get.<span class="Apple-converted-space">Â  </span>If </span><span class="s7">-fields</span><span class="s1"> is specified, you get those fields in the same order.<span class="Apple-converted-space">Â  </span>If </span><span class="s7">-fields</span><span class="s1"> is not specified, you get all the fields in the order they were defined.<span class="Apple-converted-space">Â  </span>If you have any question about the order of the fields, just ask the speed table with </span><span class="s7">$table fields</span><span class="s1">.</span></p>
<p class="p14"><span class="s7">-array_get</span><span class="s1"> works like </span><span class="s7">-get</span><span class="s1"> except that the field names and field values are written into the specified variable as a list, in a manner that <i>array get</i> can load into an array.<span class="Apple-converted-space">Â  </span>I call this "array set" format.<span class="Apple-converted-space">Â  </span>Fields that are null are not retrieved with -array_get.</span></p>
<p class="p14"><span class="s7">-array_get_with_nulls</span><span class="s1"> pulls all the fields, substituting the null value (by default, an empty string) for any fields that are null.</span></p>
<p class="p28"><span class="s1">Note it is a common bug to use </span><span class="s7">-array_get</span><span class="s1"> in a </span><span class="s7">-code</span><span class="s1"> loop, array set the returned list of key-value pairs into an array, and not <i>unset</i> the array before resuming the loop, resulting in null variables not being unset -- that is, from a previous row match, field x had a value, and in the current row, it doesn't.</span></p>
<p class="p28"><span class="s1">If you haven't unset your array, and you "array get" the new result into the array, the previous value of x will still be there.<span class="Apple-converted-space">Â  </span>So either unset (-nocomplain is a useful, not widely known optional argument to unset) or use array_get_with_nulls.</span></p>
<p class="p5"><span class="s1">Better yet would be to just use -array or -array_with_nulls, both of which directly put the stuff in an array on your behalf and do the right thing with respect to null values.</span></p>
<p class="p14"><span class="s7">-array</span><span class="s1"> sets field names and field values into the named array.<span class="Apple-converted-space">Â  </span>Any fields that are null are specifically removed (unset) from the array.</span></p>
<p class="p14"><span class="s1">Thus, if you use -array to and you with to access a field can be null, you need to check to see if the field exists (using [info exists array(fieldName)], etc) before trying to look at its value.</span></p>
<p class="p14"><span class="s1">If you donâ€™t want to do that, consider using -array_with_nulls instead.</span></p>
<p class="p14"><span class="s7">-array_with_nulls</span><span class="s1"> sets field names and field values into the named array.<span class="Apple-converted-space">Â  </span>Any fields that are null are set into the array as the null value (by default, an empty string), as set by the <i>null_value</i> method of the creator table.</span></p>
<p class="p37"><span class="s1">-compare list</span></p>
<p class="p14"><span class="s1">Perform a comparison to select rows.</span></p>
<p class="p14"><span class="s1">Compare expressions are specified as a list of lists.<span class="Apple-converted-space">Â  </span>Each list consists of an operator and one or more arguments.</span></p>
<p class="p14"><span class="s1">When the search is being performed, for each row all of the expressions are evaluated left to right and form a logical "and".<span class="Apple-converted-space">Â  </span>That is, if any of the expressions fail, the row is skipped.</span></p>
<p class="p14"><span class="s1">Here's an example:</span></p>
<p class="p29"><span class="s1">$speed table search -compare {{&gt; coolness 50} \</span></p>
<p class="p29"><span class="s1">{&gt; hipness 50}} ...</span></p>
<p class="p14"><span class="s1">In this case you're selecting every row where coolness is greater than 50 and hipness is greater than 50.</span></p>
<p class="p14"><span class="s1">Here are the available expressions:</span></p>
<p class="p37"><span class="s1">{false field}</span></p>
<p class="p14"><span class="s1">Expression compares true if fieldâ€™s value is false.<span class="Apple-converted-space">Â  </span>(For booleans, false.<span class="Apple-converted-space">Â  </span>For shorts, ints and wides, false is 0 and anything else is true.</span></p>
<p class="p37"><span class="s1">{true field}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is true.</span></p>
<p class="p37"><span class="s1">{null field}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is null.</span></p>
<p class="p37"><span class="s1">{notnull field}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is not null.</span></p>
<p class="p37"><span class="s1">{&lt; field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field less than value.<span class="Apple-converted-space">Â  </span>This works with both strings and numbers, and yes, compares the numbers as numbers and not strings.</span></p>
<p class="p37"><span class="s1">{&lt;= field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is less than or equal to value.</span></p>
<p class="p37"><span class="s1">{= field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is equal to value.</span></p>
<p class="p37"><span class="s1">{!= field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is not equal to value.</span></p>
<p class="p37"><span class="s1">{&gt;= field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is greater than or equal to value.</span></p>
<p class="p37"><span class="s1">{&gt; field value}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is greater than value.</span></p>
<p class="p37"><span class="s1">{match field expression}</span></p>
<p class="p14"><span class="s1">Expression compares true if field matches glob expression.<span class="Apple-converted-space">Â  </span>Case is insensitive.</span></p>
<p class="p37"><span class="s1">{match_case field expression}</span></p>
<p class="p14"><span class="s1">Expression compares true if field matches glob expression, case-sensitive.</span></p>
<p class="p37"><span class="s1">{notmatch field expression}</span></p>
<p class="p14"><span class="s1">Expression compares true if field does not match glob expression.<span class="Apple-converted-space">Â  </span>Case is insensitive.</span></p>
<p class="p37"><span class="s1">{notmatch_case field expression}</span></p>
<p class="p14"><span class="s1">Expression compares true if field does not match glob expression, case-sensitive.</span></p>
<p class="p37"><span class="s1">{range field low hi}</span></p>
<p class="p14"><span class="s1">Expression compares true if field is within the range of low &lt;= field &lt; hi.</span></p>
<p class="p37"><span class="s1">{in field valueList}</span></p>
<p class="p14"><span class="s1">Expression compares true if the fieldâ€™s value appears in the value list. <span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">The â€œinâ€ search expression, when used as the first search term on an indexed field has very high performance, in particular with client-server ctables, as it is much faster to go find many rows in one query than to repeatedly cause a TCP/IP command/response roundtrip on a per-row basis.</span></p>
<p class="p21"><span class="s1"><b><i>Bug: As of 1/16/07 </i></b></span><span class="s7">in</span><span class="s9"><i> </i></span><span class="s1"><b><i>only works with </i></b></span><span class="s9"><i>search+</i></span><span class="s1"><b><i>, as the first search term, when an index is defined on the field and is currently in existence<span class="Apple-converted-space">Â  </span>We expect to fully support </i></b></span><span class="s7">in</span><span class="s1"><b><i> as any search term and on fields that donâ€™t have indexes in the future.</i></b></span></p>
<p class="p14"><span class="s1">Examples:</span></p>
<p class="p14"><span class="s1">Write everything in the table tab-separated to channel $channel</span></p>
<p class="p29"><span class="s1">$speed table search -write_tabsep $channel</span></p>
<p class="p14"><span class="s1">Write everything in the table with coolness &gt; 50 and hipness &gt; 50:</span></p>
<p class="p29"><span class="s1">$speedtable search -write_tabsep $channel \</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>-compare {{&gt; coolness 50} {&gt; hipness 50}}</span></p>
<p class="p14"><span class="s1">Run some code every everything in the table matching above:</span></p>
<p class="p29"><span class="s1">$speedtable search \</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>-compare {{&gt; coolness 50} {&gt; hipness 50}} \</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â Â  Â  </span>-key key -array_get data -code {</span></p>
<p class="p29"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  </span>puts "key -&gt; $key, data -&gt; $data"</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>}</span></p>
<p class="p37"><span class="s1">-poll_interval interval</span></p>
<p class="p14"><span class="s1">Perform an </span><span class="s7">update</span><span class="s1"> operation every </span><span class="s7">interval</span><span class="s1"> rows, to allow background processing to work in the background while a long search is going on.</span></p>
<p class="p37"><span class="s1">-poll_code {code}</span></p>
<p class="p14"><span class="s1">Perform the specified </span><span class="s7">code</span><span class="s1"> every </span><span class="s7">-poll_interval</span><span class="s1"> rows. Errors from the code will be handled by the </span><span class="s7">bgerror</span><span class="s1"> mechanism. If no poll interval is specified then a default (1024) is used.</span></p>
<p class="p19"><span class="s1"><i>search+</i></span></p>
<p class="p14"><span class="s1">Search+ is a (deprecated) synonym for search.<span class="Apple-converted-space">Â </span></span></p>
<p class="p19"><span class="s1"><i>foreach</i></span></p>
<p class="p14"><span class="s1">DEPRECATED (use "search" instead)</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â </span></span><span class="s1">x foreach varName ?pattern? codeBody</span></p>
<p class="p14"><span class="s1">Iterate over all of the rows in the table, or just the rows in the table matching a string match wildcard, executing tcl code on each of them.</span></p>
<p class="p14"><span class="s1">Example:</span></p>
<p class="p29"><span class="s1">% x foreach key {</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts $key</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  </span>}</span></p>
<p class="p14"><span class="s1">This is equivalent to:</span></p>
<p class="p29"><span class="s1">% x search -key key -code {</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts $key</span></p>
<p class="p29"><span class="s1">}</span></p>
<p class="p19"><span class="s1"><i>incr</i></span></p>
<p class="p14"><span class="s1">Increment the specified numeric values, returning a list of the new incremented values</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x incr $key a 4 b 5</span></p>
<p class="p14"><span class="s1">...will increment $key's a field by 4 and b field by 5, returning a list containing the new incremented values of a and b.</span></p>
<p class="p19"><span class="s1"><i>type</i></span></p>
<p class="p14"><span class="s1">Return the "type" of the object, i.e. the name of the object-creating command that created it.</span></p>
<p class="p14"><span class="s1">% x type</span></p>
<p class="p14"><span class="s1">cable_info</span></p>
<p class="p19"><span class="s1"><i>import_postgres_result</i></span></p>
<p class="p29"><span class="s1">x import_postgres_result handle ?-nokeys? ?-nocomplain?</span></p>
<p class="p14"><span class="s1">Given a <i>Pgtcl</i> result handle, <i>import_postgresql_result</i> will iterate over all of the result rows and create corresponding rows in the table, matching the SQL column names to the field names.</span></p>
<p class="p14"><span class="s1">If the â€œ-nocomplainâ€ option is specified unknown columns in the result will be ignored.</span></p>
<p class="p14"><span class="s1">If the â€œ-nokeysâ€ option is specified the key is derived from the key column specified for the table, or autogenerated as described in read_tabsep.</span></p>
<p class="p14"><span class="s1">This is extremely fast as it does not do any intermediate Tcl evaluation on a per-row basis.</span></p>
<p class="p14"><span class="s1">How you use it is, first, execute some kind of query:</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â </span></span><span class="s1"> set res [pg_exec $connection "select * from mytable"]</span></p>
<p class="p14"><span class="s1">(You can also use </span><span class="s7">pg_exec_prepared</span><span class="s1"> or even the asynchronous <i>Pgtcl</i> commands </span><span class="s7">pg_sendquery</span><span class="s1"> and </span><span class="s7">pg_sendquery_prepared</span><span class="s1"> in association with</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span></span><span class="s7">pg_getresult</span><span class="s1"> -- see the <i>Pgtcl</i> documentation for more info.)</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Check for an error...</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â </span></span><span class="s1"> if {[pg_result $res -status] != "PGRES_RESULT_OK"} {...}</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>...and then do...</span></p>
<p class="p38"><span class="s9"><span class="Apple-converted-space">Â  Â  </span></span><span class="s1">x import_postgres_result $res</span></p>
<p class="p7"><span class="s1">Importing PostgreSQL Results Is Pretty Fast</span></p>
<p class="p28"><span class="s1">On a 2 GHz AMD64 we are able to import about 200,000 10-element rows per CPU second, i.e. around 5 microseconds per row.<span class="Apple-converted-space">Â  </span>Importing goes more slowly if one or more fields of the speed table has had an index created for it.</span></p>
<p class="p19"><span class="s1"><i>fieldtype</i></span></p>
<p class="p14"><span class="s1">Return the datatype of the named field.</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span></span><span class="s1">foreach field [x fields] {</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>puts "$field type is [x fieldtype $field]"</span></p>
<p class="p29"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>}</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span></span><span class="s1"><b><i>ip type is inet</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>mac type is mac</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>name type is varstring</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>address type is varstring</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>addressNumber type is varstring</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>geos type is varstring</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>i type is int</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>j type is int</i></b></span></p>
<p class="p29"><span class="s1"><b><i><span class="Apple-converted-space">Â  </span>ij type is long</i></b></span></p>
<p class="p19"><span class="s1"><i>needs_quoting</i></span></p>
<p class="p14"><span class="s1">Given a field name, return 1 if it might need quoting.<span class="Apple-converted-space">Â  </span>For example, varstrings and strings may need quoting as they can contain any characters, while integers, floats, IP addresses, MAC addresses, etc, do not, as their contents are predictable and their input routines do not accept tabs.</span></p>
<p class="p19"><span class="s1"><i>names</i></span></p>
<p class="p14"><span class="s1">Return a list of all of the keys in the table.<span class="Apple-converted-space">Â  </span>This is fine for small tables but can be inefficient for large tables as it generates a list containing each key, so a 650K table will generate a list containing 650K elements -- in such a case we recommend that you use <i>search</i> instead.</span></p>
<p class="p14"><span class="s1">This should probably be deprecated.</span></p>
<p class="p19"><span class="s1"><i>reset</i></span></p>
<p class="p14"><span class="s1">Clear everything out of the table.<span class="Apple-converted-space">Â  </span>This deletes all of the rows in the table, freeing all memory allocated for the rows, the rows' hashtable entries, etc.</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span>% </span><span class="s1">x count</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>652343</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span>% </span><span class="s1">x reset</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span>% </span><span class="s1">x count</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0</span></p>
<p class="p19"><span class="s1"><i>destroy</i></span></p>
<p class="p14"><span class="s1">Delete all the rows in the table, free all of the memory, and destroy the object.</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span>% </span><span class="s1">x destroy</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>% </span><span class="s7">x asdf</span></p>
<p class="p31"><span class="s9"><span class="Apple-converted-space">Â  Â </span></span><span class="s1"><b> invalid command name "x"</b></span></p>
<p class="p39"><span class="s1"><i>share</i></span></p>
<p class="p19"><span class="s1"><i>getprop</i></span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Access information about the underlying shared memory associated with a shared memory table (see the secion on shared memory, below).</span></p>
<p class="p19"><span class="s1"><i>attach</i></span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Create an attachment for a shared reader table in a shared master table. Returns a set of <i>create</i> parameters to use to complete the attachment.</span></p>
<p class="p19"><span class="s1"><i>statistics</i></span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Report information about the hash table such as the number of entries, number of buckets, bucket utilization, etc.<span class="Apple-converted-space">Â  </span>Itâ€™s fairly useless, but can give you a sense that the hash table code is pretty good.</span></p>
<p class="p29"><span class="s9">% </span><span class="s1">x</span><span class="s9"> </span><span class="s1">statistics</span></p>
<p class="p31"><span class="s1"><b>1000000 entries in table, 1048576 buckets</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 0 entries: 407387</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 1 entries: 381489</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 2 entries: 182642</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 3 entries: 59092</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 4 entries: 14490</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 5 entries: 2944</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 6 entries: 462</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 7 entries: 63</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 8 entries: 6</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 9 entries: 0</b></span></p>
<p class="p31"><span class="s1"><b>number of buckets with 10 or more entries: 1</b></span></p>
<p class="p31"><span class="s1"><b>average search distance for entry: 1.5</b></span></p>
<p class="p19"><span class="s1"><i>write_tabsep <span class="Apple-converted-space">Â </span></i></span></p>
<p class="p5"><span class="s1">DEPRECATED (use search -write_tabsep)</span></p>
<p class="p29"><span class="s1">x write_tabsep channel ?-glob pattern? ?-nokeys? ?-with_field_names? ?-tab string? ?field...?</span></p>
<p class="p14"><span class="s1">Write the table tab-separated to a channel, with the names of desired fields specified, else all fields if none are specified.</span></p>
<p class="p29"><span class="s1">set fp [open /tmp/output.tsv w]</span></p>
<p class="p29"><span class="s1">x write_tabsep $fp</span></p>
<p class="p29"><span class="s1">close $fp</span></p>
<p class="p14"><span class="s1">If the glob pattern is specified and the key of a row does not match the glob pattern, the row is not written.</span></p>
<p class="p14"><span class="s1">The first field written will be the key, unless -nokeys is specified and the key value is not written to the destination.</span></p>
<p class="p14"><span class="s1">If -with_field_names is specified, then the names of the fields will be the first row output.</span></p>
<p class="p14"><span class="s1">If -tab is specified then the string provided will be used as the tab.</span></p>
<p class="p20"><span class="s1"><b><i>BUG - We do not currently quote any tabs that occur in the data, so if there are tab characters in any of the strings in a row, that row will not be read back in properly.<span class="Apple-converted-space">Â  </span>In fact, we will generate an error when attempting to read such a row. In most cases it should be possible to select a tab separator that does not occur in any field to avoid this.</i></b></span></p>
<p class="p19"><span class="s1"><i>read_tabsep</i></span></p>
<p class="p29"><span class="s1">x read_tabsep channel ?-glob pattern? ?-nokeys? ?-with_field_names? ?-tab string? ?-skip pattern? ?field...?</span></p>
<p class="p14"><span class="s1">Read tab-separated entries from a channel, with a list of fields specified, or all fields if none are specified.</span></p>
<p class="p29"><span class="s1">set fp [open /tmp/output.tsv r]</span></p>
<p class="p29"><span class="s1">x read_tabsep $fp</span></p>
<p class="p29"><span class="s1">close $fp</span></p>
<p class="p14"><span class="s1">The first field is expected to be the key (unless -nokeys is specified) and is not included in the list of fields.<span class="Apple-converted-space">Â  </span>So if you name five fields, for example, each row in the input file (or socket or whatever) should contain six elements.</span></p>
<p class="p14"><span class="s1">It's an error if the number of fields read doesn't match the number expected.</span></p>
<p class="p14"><span class="s1">If the glob pattern is defined, it's applied to the key (first field in the row) and if it doesn't match, the row is not inserted.</span></p>
<p class="p14"><span class="s1">If </span><span class="s7">-tab string</span><span class="s1"> is specified, then the string provided will be used as the tab separator. There is no explicit limit on the length of the string, so you can use something like </span><span class="s7">-tab {%JULIE@ANDREWS%}</span><span class="s1"> with <i>read_tabsep</i> and <i>write_tabsep</i> (or <i>search -write_tabsep</i>) to reduce the possibility of a conflict.</span></p>
<p class="p14"><span class="s1">if </span><span class="s7">-skip pattern</span><span class="s1"> is specified, then lines matching that pattern are ignored. This is sometimes necessary for files containing comments.</span></p>
<p class="p14"><span class="s1">If </span><span class="s7">-with_field_names</span><span class="s1"> is specified, the first row read is expected to be a tab-separated list of field names, and Speedtables will read that line and use its contents to determine which fields each of the following lines of tab-separated values will be stored as.<span class="Apple-converted-space">Â  </span>(This is the counterpart to the </span><span class="s7">-with_field_names</span><span class="s1"> argument to speedtablesâ€™s <i>search</i> method when invoked with the </span><span class="s7">-write_tabsep</span><span class="s1"> option.)</span></p>
<p class="p40"><span class="s1">If </span><span class="s7">-nokeys</span><span class="s1"> is specified, the first field of each row is not used as the key -- rather, the key is taken from the provided fields (as if <i>makekey</i> was called for each row), and if there is no key it is automatically created as an ascending integer starting from 0. The last key generated will be returned as the value of <i>read_tabsep</i>.</span></p>
<p class="p40"><span class="s1">If you subsequently do another <i>read_tabsep</i> with -nokeys specified, the auto key will continue from where it left off.<span class="Apple-converted-space">Â  </span>If you invoke the tableâ€™s reset method, the auto key will reset to zero.</span></p>
<p class="p14"><span class="s1">If you later want to insert at the end of the table, you need to use <i>store</i> rather than <i>set</i>.</span></p>
<p class="p14"><span class="s1"><i>read_tabsep</i> stops when it reaches end of file OR when it reads an empty line.<span class="Apple-converted-space">Â  </span>Since you must have a key and at least one field, this is safe.<span class="Apple-converted-space">Â  </span>However it might not be safe with </span><span class="s7">-nokeys</span><span class="s1">.</span></p>
<p class="p14"><span class="s1">The nice thing about it is you can indicate end of input with an empty line and then do something else with the data that follows.</span></p>
<p class="p19"><span class="s1"><i>index</i></span></p>
<p class="p14"><span class="s1">Index is used to create skip list indexes on fields in a table, which can be used to greatly speed up certain types of searches.</span></p>
<p class="p29"><span class="s1">x index create foo 24</span></p>
<p class="p14"><span class="s1">...creates a skip list index on field "foo" and sets it to for an optimal size of 2^24 rows.<span class="Apple-converted-space">Â  </span>The size value is optional.<span class="Apple-converted-space">Â  </span>(How this works will be improved/altered in a subsequent release.)<span class="Apple-converted-space">Â  </span>It will index all existing rows in the table and any future rows that are added.<span class="Apple-converted-space">Â  </span>Also if a <i>set</i>, <i>read_tabsep</i>, etc, causes a row's indexed value to change, its index will be updated.</span></p>
<p class="p14"><span class="s1">If there is already an index present on that field, does nothing.</span></p>
<p class="p29"><span class="s1">x index drop foo</span></p>
<p class="p14"><span class="s1">....drops the skip list on field "foo."<span class="Apple-converted-space">Â  </span>if there is no such index, does nothing.</span></p>
<p class="p29"><span class="s1">x index dump foo</span></p>
<p class="p14"><span class="s1">...dumps the skip list for field "foo".<span class="Apple-converted-space">Â  </span>This can be useful to help understand how they work and possibly to look for problems.</span></p>
<p class="p29"><span class="s1">x index count foo</span></p>
<p class="p14"><span class="s1">...returns a count of the skip list for field "foo".<span class="Apple-converted-space">Â  </span>This number should always match the row count of the table (x count).<span class="Apple-converted-space">Â  </span>If it doesn't, there's a bug in index handling.</span></p>
<p class="p14"><span class="s1">x index span foo</span></p>
<p class="p14"><span class="s1">...returns a list containing the lexically lowest entry and the lexically highest entry in the index.<span class="Apple-converted-space">Â  </span>If there are no rows in the table, an empty list is returned.</span></p>
<p class="p29"><span class="s1">x index indexable</span></p>
<p class="p14"><span class="s1">...returns a (potentially empty) list of all of the field names that can have indexes created for them.<span class="Apple-converted-space">Â  </span>Fields must be explicitly defined as indexable when the field is created<span class="Apple-converted-space">Â  </span>with </span><span class="s7">indexed 1</span><span class="s1"> arguments.<span class="Apple-converted-space">Â  </span>(This keeps us from incurring a lot of overhead creating various things to be ready to index any field for fields that just couldnâ€™t ever reasonably be used as an index anyway.</span></p>
<p class="p29"><span class="s1">x index indexed</span></p>
<p class="p14"><span class="s1">...returns a (potentially empty) list of all of the field names in table x that current have an index in existence for them, meaning that index create has been invoked on that field.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Special Notes On How To Make Searches Go Fast</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>6</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Special Notes On How To Make Searches Go Fast</span></p>
<p class="p4"><span class="s1">This chapter explains how to make Speed Table searches go as fast as possible.</span></p>
<p class="p14"><span class="s1">An example of brute force searching that there isnâ€™t much getting around without adding fancy full-text search is unanchored text search.<span class="Apple-converted-space">Â  </span>Even in this case, with our fast string search algorithm and quick traversal during brute-force search, weâ€™re seeing 60 nanoseconds per row or searching about sixteen million rows per CPU second on circa-2006 AMD64 machines.</span></p>
<p class="p14"><span class="s1">Although many optimizations are being performed by the speed table compiler, further performance improvements can be made without introducing huge new complexities, perturbations, etc.</span></p>
<p class="p41"><span class="s1">If you need to search for ranges of things, partial matches, straight equality of a field other than the key field, etc, you can use indexes and the â€œrangeâ€, â€œ=â€, and â€œinâ€ compare functions to obtain huge search performance improvements over brute force, subject to a number of limitations:<span class="Apple-converted-space">Â  </span>First, the table must have had an index created on that field using </span><span class="s7">$speedtable index create $fieldName</span><span class="s1">.<span class="Apple-converted-space">Â </span></span></p>
<p class="p4"><span class="s1">Speed Table Query Optimizer</span></p>
<p class="p14"><span class="s1">The Speed Table Query Optimizer has been rolled in to search, and search+ has been deprecated. The â€œbestâ€ field in the query is used as the index, in this order:</span></p>
<p class="p14"><span class="s1">â€œ<b>in</b>â€ has the highest priority, but the field used MUST be the key field or an indexed field.</span></p>
<p class="p14"><span class="s1">â€œ<b>=</b>â€ has the next highest priority.</span></p>
<p class="p14"><span class="s1">â€œ<b>&lt;</b>â€œ, â€œ<b>&lt;=</b>â€, or â€œ<b>&gt;=</b>â€ come next.</span></p>
<p class="p14"><span class="s1">â€œ<b>&gt;</b>â€ comes after these</span></p>
<p class="p14"><span class="s1">All other searches are last priority.</span></p>
<p class="p14"><span class="s1">In an ordered search, with an increasing sort, the sort field gets chosen when possible<span class="Apple-converted-space">Â  </span>to avoid manually sorting the results after finding them.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Client-Server Speed Tables</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>7</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Client-Server Speed Tables</span></p>
<p class="p4"><span class="s1">This chapter describes the rationale for creating a client-server interface to Speed Tables, explains the pluses and minuses of the current implementation, explains how to use the client interface, and gives an example of how to use it.</span></p>
<p class="p5"><span class="s1">Tables created with Speed Tables, as currently implemented, are local to the Tcl interpreter that created them.</span></p>
<p class="p5"><span class="s1">A version that uses shared memory and supports multiple readers is now available. It maintains the entire table, keys, and indexes in shared memory, and may be used when there is sufficient physical memory available. It operates locklessly and so does not support multiple writers.</span></p>
<p class="p5"><span class="s1">Only the â€œsearchâ€ command operates over the shared memory interface, all other commands use the client-server API.</span></p>
<p class="p5"><span class="s1">Even with these limitations, client-server shared speed tables can be quite useful.</span></p>
<p class="p42"><span class="s1">Early in our work it became clear that we needed a client-server way to talk to Speed Tables that was highly compatible with accessing Speed Tables natively.</span></p>
<p class="p5"><span class="s1">The simplicity and uniformity of the speed tables interface and the rigorous use of key-value pairs as arguments to search made it possible to implement a Speed Tables client and server in around 500 lines of Tcl code. This code implements the Speed Table Transfer Protocol (STTP).</span></p>
<p class="p5"><span class="s1">This implementation provides near-identical behavior for client-server Speed Tables as direct Speed Tables for <i>get, set, array_get, array_get_with_nulls, exists, delete, count, type, fields, fieldtype, needs_quoting, names, reset, destroy, statistics, </i>and<i> search</i>.</span></p>
<p class="p5"><span class="s1">The main exception is that it is not possible to call speedtable commands from within a code body running in a search, unless you use the shared-memory search to speed things up.</span></p>
<p class="p43"><span class="s1"></span><br></p>
<p class="p7"><span class="s1">Authentication, lack thereof</span></p>
<p class="p28"><span class="s1">The current implementation of the speed table server does <b>no authentication</b>, so it is only appropriate for use behind a firewall or with a protection mechanism â€œin front ofâ€ it.</span></p>
<p class="p5"><span class="s1">For instance, you might use your systemâ€™s firewall rules to prevent access to the ports speed table server is using (or youâ€™re having it use) other than between the machines you designate.<span class="Apple-converted-space">Â  </span>Alternatively you could add the TLS extension, do authentication and substitute SSL sockets for the plain ones -- Speed Tables wouldnâ€™t even notice a difference.</span></p>
<p class="p5"><span class="s1">There is a Tcl interpreter on the server side, pointing to the possibility of deploying server-side code to interact with Speed Tables</span><span class="s6"><sup></sup></span><span class="s1">, although there isnâ€™t any formal mechanism for creating and loading server-side code at this time.</span></p>
<p class="p5"><span class="s1">Speed Tablesâ€™ <i>register</i> method appears to be a natural fit for implementing an interface to row-oriented server-side code invoked from a client.</span></p>
<p class="p5"><span class="s1">Speed Tables can be operated in safe interpreters if desired, as one part of a solution for running server-side code, should you choose to take it on.</span></p>
<p class="p5"><span class="s1">Once you start considering using Speed Tables as a way to cache tens of millions of rows of data across many tables, if the application is large enough, you may start to consider having machines basically serve as dedicated Speed Table servers.</span></p>
<p class="p44"><span class="s1">Take generic machines and stuff them with the max amount of RAM at your appropriate density/price threshold.<span class="Apple-converted-space">Â  </span>Boot up your favorite Linux or BSD off of a small hard drive, thumb drive, or from the network.<span class="Apple-converted-space">Â  </span>Start up your Speed Tables server processes, load them up with data, and start serving speed tables at far higher performance that traditional SQL databases.</span></p>
<p class="p24"><span class="s1">Speed Table URLs</span></p>
<p class="p45"><span class="s1">sttp://foo.com/bar</span></p>
<p class="p45"><span class="s1">sttp://foo.com:2345/bar</span></p>
<p class="p45"><span class="s1">sttp://foo.com/bar/snap</span></p>
<p class="p45"><span class="s1">sttp://foo.com:1234/bar/snap</span></p>
<p class="p45"><span class="s1">sttp://foo.com/bar?moreExtraStuff=sure</span></p>
<p class="p5"><span class="s1">The default speed table client/server port is 11111.<span class="Apple-converted-space">Â  </span>It can be overridden as above.<span class="Apple-converted-space">Â  </span>Thereâ€™s a host name, an optional port, an optional directory, a table name, and optional extra stuff.<span class="Apple-converted-space">Â  </span>Currently the optional directory and optional extra stuff are parsed, but ignored.</span></p>
<p class="p5"><span class="s1">A typical server-side use of a speed table URL wildcards the hostname:</span></p>
<p class="p45"><span class="s1">sttp://*:2345/bar</span></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Example Client Code</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">package require speedtable_client</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">remote_ctable sttp://127.0.0.1/dumbData t</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">t search -sort -coolness -limit 5 -key key -array_get_with_nulls data -code {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â Â  Â  </span>puts â€œ$key -&gt; $dataâ€<span class="Apple-converted-space">Â </span></span></p>
<p class="p30"><span class="s1">}</span></p>
<p class="p48"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Example Server Code</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">package require ctable_server</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">::ctable_server::register sttp://*/dumbData t</span></p>
<p class="p49"><span class="s1"></span><br></p>
<p class="p44"><span class="s1">Thatâ€™s all there is to it.<span class="Apple-converted-space">Â  </span>You have to allow the Tcl event loop to run, either by doing a <i>vwait </i>or by periodically calling <i>update</i> if your application is not event-loop driven, but as long as you do so, your app will be able to server out speedtables.</span></p>
<p class="p24"><span class="s1">Client-Server Performance</span></p>
<p class="p5"><span class="s1">Performance of client-server speed tables is necessarily slower than that of native, local speed tables.<span class="Apple-converted-space">Â  </span>Network round-trips and the Tcl interpreter being involved on both the client and server side for every method invoked on a remote speed table inevitably impacts performance.</span></p>
<p class="p44"><span class="s1">That being said, a couple of techniques we will now explain can have a dramatic impact on client/server speed table performance.</span></p>
<p class="p24"><span class="s1">Batching Client-Server Speed Table Operations for Speed</span></p>
<p class="p50"><span class="s1">Consider a case where you know youâ€™re going to set values in dozens to hundreds of rows in a table.<span class="Apple-converted-space">Â  </span>You can batch up the sets into a single batch set command.</span></p>
<p class="p30"><span class="s1">$remoteCtable set key1 var value ?var value...?</span></p>
<p class="p30"><span class="s1">$remoteCtable set key2 var value ?var value...?</span></p>
<p class="p30"><span class="s1">$remoteCtable set key3 var value ?var value...?</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">$remoteCtable batch {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set key1 var value ?var value...?</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set key2 var value ?var value...?</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set key3 var value ?var value...?</span></p>
<p class="p29"><span class="s1">}</span></p>
<p class="p5"><span class="s1">In the second example, all of the set commands are sent over in a single remote speed table command, processed as a single batch by the speed table server (with no Tcl interpreter involvement in processing on a per-command basis inside the batch). <span class="Apple-converted-space">Â  </span>A list is returned comprising the results of all of the commands executed.<span class="Apple-converted-space">Â  </span>(See the batch method for more details.)</span></p>
<p class="p44"><span class="s1">Most speed table commands can be batched, except for the search methods, the results of attempting such a thing being undefined.<span class="Apple-converted-space">Â  </span>In particular, get, delete, and exists can be pretty useful.</span></p>
<p class="p24"><span class="s1">Using Client-Server Search To Get Many Rows At Once</span></p>
<p class="p50"><span class="s1">Another common use of speed tables is to retrieve values from rows in some kind of loop.<span class="Apple-converted-space">Â  </span>Perhaps something like...</span></p>
<p class="p51"><span class="s1">foreach key $listOfRows {</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set data [$ctable get $key]</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>....</span></p>
<p class="p35"><span class="s1">}</span></p>
<p class="p50"><span class="s1">Unfortunately there is only a single channel for communication, and the server is single-threaded, so this doesnâ€™t work. Even if it did, every â€œgetâ€ would cause a network roundtrip to the speed table server handling that table.<span class="Apple-converted-space">Â  </span>If we substitute a search for the above, we can get all the data for all the rows in a single roundtrip.<span class="Apple-converted-space">Â  </span>The â€œinâ€ compare method can be particularly useful for this...</span></p>
<p class="p51"><span class="s1">$ctable search -compare {in key $listOfRows} -array_with_nulls data {</span></p>
<p class="p51"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>....</span></p>
<p class="p52"><span class="s1">}</span></p>
<p class="p7"><span class="s1">STTP does not support NULLs.</span></p>
<p class="p28"><span class="s1">Note that -array_with_nulls retrieves null fields. STTP passes rows around internally as token separated files, and hence when used in client-server speed tables there is no equivalent to -array or -array_get.</span></p>
<p class="p28"><span class="s1">Because tab-separated data doesnâ€™t have an out-of-band facility for communicating that a field is null, null values must be communicated in-band.</span></p>
<p class="p24"><span class="s1">STAPI support for ctable_server</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">The success of the ctable_server led to the creation of a generic URI-based API for the ctable server and for other ctable-compatible objects and classes. This API, STAPI, allows ctables, the ctable server, and other compatible objects to be used interchangably by applications.</span></p>
<p class="p5"><span class="s1">To open a table using the STAPI you need to </span><span class="s7">package require </span><span class="s1">any packages needed for the STAPI connection method you need, then call</span></p>
<p class="p45"><span class="s1">::stapi::connect method://server_spec/table_spec</span></p>
<p class="p5"><span class="s1">For the speedtable server, the method is </span><span class="s7">ctable:</span><span class="s1"> (as above) or</span><span class="s7"> sttp</span><span class="s1">: (speed tables transfer protocol), and the URI syntax is exactly the same as in </span><span class="s7">remote_speedtable</span></p>
<p class="p5"><span class="s1">As a special case, when the URI is not in URI format it is assumed to be the name of an already opened ctable.</span></p>
<p class="p5"><span class="s1">STAPI connection methods already defined a;so include sql, which provides direct access to PostgreSQL tables through pgsql as if they were ctables.</span></p>
<p class="p5"><span class="s1">STAPI is described in more detail in section 9.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Shared Memory Speed Tables</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>8</span></p>
<p class="p54"><span class="s1"></span><br></p>
<p class="p34"><span class="s1">Shared Memory Speed Tables</span></p>
<p class="p14"><span class="s1">Client-server speed tables can take a fairly big performance hit, as a sizable amount of Tcl code gets executed to make the remote speed table function like a local one.</span></p>
<p class="p14"><span class="s1">While theyâ€™re still pretty fast, server actions are inherently serialized because of the single-threaded access model afforded using standard Tcl fileevent actions within the Tcl event model.</span></p>
<p class="p14"><span class="s1">When the speed table resides on the same machine as the client, and particularly in this era of relatively inexpensive multiprocessor systems, it would be highly desirable for a client to be able to access the speed table directly through shared memory, bypassing the server entirely.</span></p>
<p class="p14"><span class="s1">This work was undertaken in the summer of â€™07 by Peter da Silva.<span class="Apple-converted-space">Â  </span>The goal was to provide a way for same-server clients to access the speed table through shared memory while retaining the ability to build and use speed tables without using shared memory at all.</span></p>
<p class="p14"><span class="s1">Tricky synchronization issues surfaced immediately.<span class="Apple-converted-space">Â  </span>For instance, what should we do if a row gets changed or added while a search is being performed?<span class="Apple-converted-space">Â  </span>We donâ€™t want to completely lock out access to the table during a search.<span class="Apple-converted-space">Â  </span>Thus we have to really deal with database updates during searches, which raise referential integrity issues and garbage collection / dangling pointer issues.<span class="Apple-converted-space">Â  </span>Many searches, such as ones involving results sorting, collecting a set of pointers to the rows that have matched.<span class="Apple-converted-space">Â  </span>Those rows cannot disappear behind searchâ€™s back.</span></p>
<p class="p14"><span class="s1">Also the code was already in heavy production with tables containing tens of millions of rows.<span class="Apple-converted-space">Â  </span>This work had to be rock solid or it wouldnâ€™t be usable.</span></p>
<p class="p14"><span class="s1">To simplify the problem, we decided to funnel writes through the client/server mechanism and only allows reads and searches to occur through shared memory.</span></p>
<p class="p14"><span class="s1">Our approach is to maintain metadata about in-progress searches in shared memory and have a cycle number that increases as the database is updated.<span class="Apple-converted-space">Â  </span>When a search begins, the client copies the current cycle number to a word in shared memory allocated for it by the server.<span class="Apple-converted-space">Â  </span>As normal activity causes rows to be modified, updated. or deleted by the server the cycle they were modified on is stored in the row. If rows (or any other shared memory object, such as strings) are deleted, they are added to a garbage pool along with the current cycle, but not actually freed for reuse until the server garbage collects them on a later cycle.</span></p>
<p class="p14"><span class="s1">If the client detects that a row itâ€™s examining has been modified since it started its search, it restarts the search operation. The server makes sure to update pointers within shared memory in an order such that the client will never step into a partially modified structure. This allows the whole operation to proceed without explicit locks, so long as pointer and cycle updates are atomic and ordered.</span></p>
<p class="p14"><span class="s1">Garbage collection is performed by locating deleted memory elements that have a cycle number is lower than the cycle number of any client currently performing a search.</span></p>
<p class="p14"><span class="s1">New options to the ctable â€œcreateâ€ command:</span></p>
<p class="p19"><span class="s1"><i>$ctable create name master list</i></span></p>
<p class="p14"><span class="s1">Creates a new master table based on the parameters in the list.</span></p>
<p class="p14"><span class="s1">name tablename (optional)</span></p>
<p class="p14"><span class="s1">The shared memory segment has a small write-once symbol table that is used to locate individual ctables and other objects in shared mem.</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>file filename (required)</span></p>
<p class="p14"><span class="s1">Multiple tables can be mapped in the same file, distinguished by the ctable name or the name provided in the "name" option.</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>size bytes (required)</span></p>
<p class="p14"><span class="s1">Used to create the file, or if it's already mapped it checks if it's at least this big.</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>flags list</span></p>
<p class="p14"><span class="s1">The only shared memory flags implemented are sync/nosync (default nosync) and core/nocore (default core).</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p19"><span class="s1"><i>$ctable create name reader list</i></span></p>
<p class="p14"><span class="s1">The list provided is collected from the master table (already opened in another process) through the attach command (below).</span></p>
<p class="p14"><span class="s1">This attaches to an existing shared memory segment based on the information in the list, then searches for the reader cycle tagged by the process ID provided to attach, and creates a reader-mode ctable. This table contains a pointer to the master ctable in shared memory, data copied from the master, and other bookkeeping elements.<span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">New ctable commmands:</span></p>
<p class="p19"><span class="s1"><i>$ctable attach pid</i></span></p>
<p class="p14"><span class="s1">Only valid for a master shared ctable, Creates a cycle entry for the process pid, and returns a list of parameters that describe how to attach to the ctable. Currently {file $file name $name}, where "file" is the file to map and "name" is the name of the shared ctable in the directory.</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p19"><span class="s1"><i>$ctable getprop</i></span></p>
<p class="p14"><span class="s1">With no names, returns a name-value list of properties of the ctable, whatever is needed for reflection.</span></p>
<p class="p14"><span class="s1">Currently type, extension, and key. These are needed for the STAPI glue for shared tables.</span></p>
<p class="p19"><span class="s1"><i>$ctable getprop name ...</i></span></p>
<p class="p14"><span class="s1">With names, returns a list of only those properties.</span></p>
<p class="p39"><span class="s1"><i>share command [$ctable share] ?options?</i></span></p>
<p class="p19"><span class="s1"><i>$ctable share command ?options?</i></span></p>
<p class="p14"><span class="s1">These are equivalent ways of doing the same thing.<span class="Apple-converted-space">Â  </span>The "share" extension actually stands apart from the ctable extension and Tcl. It provides the shared memory segments and handles memory allocation from the segments. It's unlikely to be useful to use the explicit share form except in internal debugging. The rest of the doc assumes you're using "$ctable share command".</span></p>
<p class="p14"><span class="s1">The following commands are meaningful for ctable shares:</span></p>
<p class="p14"><span class="s1">names</span></p>
<p class="p14"><span class="s1">Returns a list of named objects in the share. These are not necessarily ctables, they may be string variables or objects created by other libraries.</span></p>
<p class="p14"><span class="s1">set name string <i>(master only)</i></span></p>
<p class="p14"><span class="s1">Sets a shared string variable, for passing additional environment or context to readers.</span></p>
<p class="p14"><span class="s1">get name</span></p>
<p class="p14"><span class="s1">Gets the value of a string set with "set".</span></p>
<p class="p14"><span class="s1">info</span></p>
<p class="p14"><span class="s1">Returns some internal information about the share in a name-value list. The data includes size, flags, name, whether you're the creator <i>(master)</i>, and filename.</span></p>
<p class="p14"><span class="s1">pools</span></p>
<p class="p14"><span class="s1">Returns a list of information for fixed size memory pools in the shared segment. There will be at least two pools, the garbage pool (containing elements that have been freed but are still in use by at least one reader) and one pool the size of a ctable row is set up for each ctable. For each pool it will return the size of elements that the pool will manage, how many elements in each chunk of elements allocated at once, the total number of chunks allocated, and the number of free elements: </span><span class="s7">{element_size elements_per_chunk chunks free_elements}</span><span class="s1"><span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1">pool element_size elements_per_chunk max_chunks</span></p>
<p class="p14"><span class="s1">Creates a pool for objects of element_size bytes, allocated in elements_per_chunk chunks, up to a maximum of max_chunks. If max_chunks is zero it will extend to pool to the limit of the shared segment if necessary.</span></p>
<p class="p24"><span class="s1">STAPI support for shared memory tables:</span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">package require st_shared</span></p>
<p class="p29"><span class="s1">::stapi::connect shared://port/table ?options?</span></p>
<p class="p14"><span class="s1">Options:</span></p>
<p class="p14"><span class="s1">-build path ... directory containing the generated ctable package.</span></p>
<p class="p14"><span class="s1">Connect to a ctable on localhost as a ctable_server client, and then open a parallel shared memory client for the same ctable. These connections are hidden behind a STAPI wrapper, so all ctable commands can be used: shared memory will be used for read-only â€œsearchâ€ commands, and the ctable_server TCP connection will be used for all other commands.</span></p>
<p class="p14"><span class="s1">Server example:</span></p>
<p class="p30"><span class="s1">top_brands_nokey_m create m master file sharefile.dat</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>[...]</span></p>
<p class="p30"><span class="s1">::ctable_server::register ctable://*:1616/master m</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>[...]</span></p>
<p class="p29"><span class="s1">if !$tcl_interactive { vwait die }</span></p>
<p class="p14"><span class="s1">This is just like a normal ctable server, except that the ctable itself is a shared memory master table.</span></p>
<p class="p14"><span class="s1">Client example:</span></p>
<p class="p30"><span class="s1">package require st_shared</span></p>
<p class="p30"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  </span>[...]</span></p>
<p class="p30"><span class="s1"># Connect to the server, using the shared ctable</span></p>
<p class="p30"><span class="s1"># extension created by the server in the directory</span></p>
<p class="p30"><span class="s1"># â€œbuildâ€. Returns a stapi object.</span></p>
<p class="p30"><span class="s1">set r [::stapi::connect shared://1616/master -build build]</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1"># This command is performed using shared memory.</span></p>
<p class="p30"><span class="s1">$r search -compare {{= name phred}} -key k -code {puts $k}</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1"># This command is performed using TCP</span></p>
<p class="p30"><span class="s1">$r set fred $row</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1"># Close the reader and disconnect from the server.</span></p>
<p class="p29"><span class="s1">$r destroy</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1"></span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>stapi - Speed Table API</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>9</span></p>
<p class="p54"><span class="s1"></span><br></p>
<p class="p34"><span class="s1">stapi - Speed Table API</span></p>
<p class="p14"><span class="s1">STAPI allows the speedtables API, originally implemented in ctables, to be used for a variety of table-like objects. This includes remote ctables through ctable_server and SQL databases. There are two main sets of routines in STAPI, and theyâ€™re not normally used together.</span></p>
<p class="p14"><span class="s1">st_server, a set of routines for automatically creating a ctable from an SQL table as a local read_only cache for the table, or as a workspace to be used for preparing rows to be inserted into the table. Itâ€™s normally used in a ctable_server task providing a local cache for client processes.</span></p>
<p class="p14"><span class="s1">st_client, which provides the general interface for creating STAPI objects identified by URIs.</span></p>
<p class="p14"><span class="s1">Normally,<span class="Apple-converted-space">Â </span></span></p>
<p class="p24"><span class="s1">st_server</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p45"><span class="s1">package require st_server</span><span class="s9"><br>
<i>::stapi::init</i> </span><span class="s1">?options?</span></p>
<p class="p5"><span class="s1">Options:</span></p>
<p class="p45"><span class="s9">-</span><span class="s1">dir</span><span class="s9"> </span><span class="s1">work_directory</span></p>
<p class="p5"><span class="s1">Root of directory tree for the ctables</span></p>
<p class="p45"><span class="s9">-</span><span class="s1">mode</span><span class="s9"> </span><span class="s1">mode</span></p>
<p class="p5"><span class="s1">Octal UNIX mode bits for new directories</span></p>
<p class="p45"><span class="s9">-</span><span class="s1">conn</span><span class="s9"> </span><span class="s1">connection</span></p>
<p class="p5"><span class="s1">Pgsql connection (if not specified, assumes DIO is being used and a DIO object named DIO exists and has already been connected to the database)</span></p>
<p class="p5"><span class="s1">-cache minutes</span></p>
<p class="p5"><span class="s1">How long to treat a cached tsv file as "good"</span></p>
<p class="p45"><span class="s9"><i>::stapi::init_ctable </i></span><span class="s1">name</span><span class="s9"><i> </i></span><span class="s1">table_list</span><span class="s9"><i> </i></span><span class="s1">where_clause</span><span class="s9"><i> </i></span><span class="s1">?columns|column...?</span></p>
<p class="p5"><span class="s1">Initialize a cached speed table based on one or more SQL tables.<span class="Apple-converted-space">Â  </span>If necessary, this builds a ctable based on the columns, and generates new SQL to read the table.</span></p>
<p class="p5"><span class="s1">Parameters:</span></p>
<p class="p45"><span class="s1">name</span></p>
<p class="p5"><span class="s1">base name of speed table</span></p>
<p class="p45"><span class="s1">table_list</span></p>
<p class="p5"><span class="s1">list of SQL tables to extract data from.<span class="Apple-converted-space">Â  </span>If it's empty then use the base name of the speed table as the name of the SQL table.</span></p>
<p class="p45"><span class="s1">where_clause</span><span class="s9"><span class="Apple-converted-space">Â </span></span></p>
<p class="p5"><span class="s1">An optional SQL "WHERE" clause to limit the rows selected into the speed table, or an empty string</span></p>
<p class="p45"><span class="s1">columns</span></p>
<p class="p5"><span class="s1">list of column definitions.</span></p>
<p class="p5"><span class="s1">At least two columns must be defined -- the first is the speed table key, the rest are the fields of the ctable. If there is only one "column" argument, it's assumed to be a list of column arguments.</span></p>
<p class="p5"><span class="s1">Column entries are each a list of<span class="Apple-converted-space">Â </span></span></p>
<p class="p45"><span class="s1">{field type expr ?name value?...}</span></p>
<p class="p45"><span class="s1">field</span></p>
<p class="p5"><span class="s1">field name</span></p>
<p class="p45"><span class="s1">type</span></p>
<p class="p5"><span class="s1">SQL type</span></p>
<p class="p45"><span class="s1">expr</span></p>
<p class="p5"><span class="s1">SQL expression to derive the value</span></p>
<p class="p45"><span class="s1">name</span><span class="s9"> </span><span class="s1">value</span></p>
<p class="p5"><span class="s1">speed table arguments for the field</span></p>
<p class="p5"><span class="s1">(Only the field name is absolutely required.)</span></p>
<p class="p5"><span class="s1">If the type is missing or blank, it's assumed to be <i>varchar</i>.<span class="Apple-converted-space">Â  </span>If the expression is missing or blank, it's assumed to be the same as the field name.</span></p>
<p class="p5"><span class="s1">In most cases the list of column definitions can be created by querying the SQL database itself using </span><span class="s7">from_table</span><span class="s1">:</span></p>
<p class="p5"><span class="s1"><i>::stapi::from_table table_name</i> </span><span class="s7">keys</span><span class="s1"> ?</span><span class="s7">-option</span><span class="s1"> </span><span class="s7">value</span><span class="s1">?</span></p>
<p class="p5"><span class="s1">Generate a column list for </span><span class="s7">init_ctable</span><span class="s1"> by querying the SQL database for the table definition.</span></p>
<p class="p45"><span class="s1">keys</span></p>
<p class="p5"><span class="s1">a list of columns that define the key for the table</span></p>
<p class="p5"><span class="s1">Keys can be empty, to allow you to combine from_table lists with an appropriate "WHERE" clause to use </span><span class="s7">init_ctable</span><span class="s1"> to create a view that spans tables.</span></p>
<p class="p5"><span class="s1">Options:</span></p>
<p class="p45"><span class="s1">-with</span><span class="s9"> </span><span class="s1">column</span></p>
<p class="p5"><span class="s1">Include column name in table. If <i>any</i> </span><span class="s7">-with</span><span class="s1"> clauses are provided, only the named columns will be included.</span></p>
<p class="p45"><span class="s1">-without</span><span class="s9"> </span><span class="s1">column</span></p>
<p class="p5"><span class="s1">Exclude column name from table. You must not provide both "-with" and "-without" options.</span></p>
<p class="p45"><span class="s1">-index</span><span class="s9"> </span><span class="s1">column</span></p>
<p class="p5"><span class="s1">Make this column indexable. The index will actually be created after the cache is loaded.</span></p>
<p class="p45"><span class="s1">-column</span><span class="s9"> </span><span class="s1">{name type ?sql? ?args}</span></p>
<p class="p5"><span class="s1">Add an explicit derived column. This can be used for the creation of ctables from SQL tables that have multi-column keys.</span></p>
<p class="p45"><span class="s1">-table</span><span class="s9"> </span><span class="s1">name</span></p>
<p class="p5"><span class="s1">If specified, generate implicit column-name as "table.column" in the SQL. This allows for the cache to be created from a query on more than one table.</span></p>
<p class="p45"><span class="s1">-prefix</span><span class="s9"> </span><span class="s1">text</span></p>
<p class="p5"><span class="s1">If specified, prefix column names with "$prefix"</span></p>
<p class="p45"><span class="s1">::stapi::open_cached name</span><span class="s9"> </span><span class="s1">?pattern?</span><span class="s9"> </span><span class="s1">?-opt val?</span><span class="s9">...</span></p>
<p class="p5"><span class="s1">Open an initialized speed table, maintaining a local cache of the underlying SQL table in a .tsv file in the workdir.</span></p>
<p class="p5"><span class="s1">Options</span></p>
<p class="p45"><span class="s1">-pat</span><span class="s9"> </span><span class="s1">pattern</span></p>
<p class="p5"><span class="s1">Only read lines matching the pattern from the cache, if the cache is good.<span class="Apple-converted-space">Â  </span>This is an optimization to avoid reading the entire table into memory when only a part of the table will be used . If the cache is old or missing, then the entire table will still be read into memory.</span></p>
<p class="p45"><span class="s1">-time cache_timeout</span></p>
<p class="p5"><span class="s1">Override the default cache timeout.</span></p>
<p class="p45"><span class="s1">-col</span><span class="s9"> </span><span class="s1">name</span></p>
<p class="p5"><span class="s1">Name of column in the table that contains the last_changed time of each entry, if any. This is used as an optimization to only load modified lines when the schema supports that.</span></p>
<p class="p45"><span class="s1">-index</span><span class="s9"> </span><span class="s1">field_name</span></p>
<p class="p5"><span class="s1">Name of a field to create an index on. Multiple </span><span class="s7">-index</span><span class="s1"> entries are allowed.</span></p>
<p class="p45"><span class="s1">::stapi::refresh_ctable</span><span class="s9"> </span><span class="s1">ctable</span><span class="s9"> </span><span class="s1">?last_read?</span><span class="s9"> </span><span class="s1">?err?</span></p>
<p class="p5"><span class="s1">Update new rows from SQL for speed table </span><span class="s7">ctable</span><span class="s1">.</span></p>
<p class="p5"><span class="s1">If </span><span class="s7">last_read</span><span class="s1"> is non-zero, use that rather than last modify time of the cache file.</span></p>
<p class="p5"><span class="s1">If </span><span class="s7">err</span><span class="s1"> is provided, it will return success or failure of the SQL request and put the error in <i>$err</i>, otherwise it will generate a Tcl error for SQL errors.</span></p>
<p class="p5"><span class="s1">This uses the parameters set up in </span><span class="s7">open_cached</span><span class="s1">, and if there is no column in the table that can be used to determine the last change time, then the whole table will be re-read.</span></p>
<p class="p45"><span class="s1">::stapi::save_ctable ctable</span><span class="s9"> </span><span class="s1">?tsv_file?</span></p>
<p class="p5"><span class="s1">Save a table locally on disk. If the</span><span class="s7"> tsv_file</span><span class="s1"> is provided, it writes to that file.<span class="Apple-converted-space">Â  </span>If not, it locates and locks the existing tsv file for the table, writes it, and unlocks it. This does not save the table back to the SQL data source.</span></p>
<p class="p45"><span class="s1">::stapi::remove_tsv_file</span><span class="s9"> </span><span class="s1">table_name</span></p>
<p class="p45"><span class="s1">::stapi::remove_tcl_file</span><span class="s9"> </span><span class="s1">table_name</span></p>
<p class="p5"><span class="s1">Remove the cached <b>tcl</b> or <b>tsv</b> files, which will force the cache to be reread (if the <b>tsv</b> file is missing) or reconstructed using SQL queries (if the <b>tcl</b> file is missing). These are not normally used directly, but are available if the table is known to be out of date.</span></p>
<p class="p45"><span class="s1">::stapi::open_raw_ctable</span><span class="s9"> </span><span class="s1">name</span></p>
<p class="p44"><span class="s1">Open an initialized speed table (as in </span><span class="s7">open_cached</span><span class="s1">) but don't fetch anything from SQL. This is used internally by </span><span class="s7">open_cached</span><span class="s1">, and is also useful for setting up temporary tables and workspaces.</span><span class="s11">st_client</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">st_client implements that ::stapi::connect front end for ctables and other speedtable API objects.</span></p>
<p class="p56"><span class="s1"></span><br></p>
<p class="p45"><span class="s1">::stapi::connect uri</span><span class="s9"> </span><span class="s1">?-name value...?</span></p>
<p class="p5"><span class="s1">Connect to a speed table server or other database providing a speed table interface via a URI.</span></p>
<p class="p5"><span class="s1">Returns an open speed table.</span></p>
<p class="p5"><span class="s1">Options:</span></p>
<p class="p45"><span class="s1">-key</span><span class="s9"><span class="Apple-converted-space">Â  </span></span><span class="s1">col</span></p>
<p class="p5"><span class="s1">Define the column used to generate the key.</span></p>
<p class="p45"><span class="s1">-keys</span><span class="s9"> </span><span class="s1">{col col ...}</span></p>
<p class="p5"><span class="s1">Define the columns used to generate the key.</span></p>
<p class="p45"><span class="s1">-keysep</span><span class="s9"> </span><span class="s1">"string"</span></p>
<p class="p5"><span class="s1">Define the separator used to build the key.</span></p>
<p class="p5"><span class="s1">One of -key or -keys/-keysep should be provided. Depending on the underlying object, -keys may not be compatible and STAPI will need to create a wrapper function.</span></p>
<p class="p5"><span class="s1">If neither is provided, some STAPI capabilities may not be available.</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p45"><span class="s1">::stapi::register method transport_handler</span></p>
<p class="p5"><span class="s1"><span class="Apple-converted-space">Â  </span>register a transport method for ::stapi::connectAt this time the following methods are defined in STAPI:</span></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Using a ctable server via sttp (client/server)</span></p>
<p class="p45"><span class="s1">package require <i>st_client</i></span></p>
<p class="p57"><span class="s1"><b>sttp://[host:port]/[dir/]table[/stuff][?stuff]</b></span></p>
<p class="p58"><span class="s9">(or </span><span class="s1"><b>ctable://[host:port]/[dir/]table[/stuff][?stuff]</b></span><span class="s9"> )</span></p>
<p class="p55"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Using a ctable server via sttp (shared memory)</span></p>
<p class="p45"><span class="s1">package require <i>st_shared</i></span></p>
<p class="p57"><span class="s1"><b>shared://port/[dir/]table[/stuff][?stuff]</b></span></p>
<p class="p5"><span class="s1">Access a speed table server on localhost, using shared memory for the "search" method and sttp: for other methods.</span></p>
<p class="p5"><span class="s1">The speed table must reside on the same machine for shared memory table access to be used.<span class="Apple-converted-space">Â  </span>Concurrent access and update of shared memory speed tables is supported and provides a mechanism to use multiple processors to access a table concurrently.<span class="Apple-converted-space">Â  </span>Like, really concurrently, whereas pure client/server table access is inherently single threaded.</span></p>
<p class="p5"><span class="s1">The ctable built by the server must be in auto_path, or in the directory defined by the "-build" option.</span></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Using a PostgreSQL database directly</span></p>
<p class="p45"><span class="s1">package require <i>st_client_pgtcl</i></span></p>
<p class="p45"><span class="s1">::stapi::init_conn connection</span></p>
<p class="p45"><span class="s1">::stapi::init_DIO ?db? ?user?</span></p>
<p class="p45"><span class="s1"><b>sql://connection/table[/col[:type]/col...][?param&amp;param...]</b></span></p>
<p class="p5"><span class="s1">Create a stapi interface to a PostgreSQL table</span></p>
<p class="p5"><span class="s1">connection:</span></p>
<p class="p5"><span class="s1">Not implemented yet, will be:</span></p>
<p class="p5"><span class="s1">[user[:password]]@[host:]database</span></p>
<p class="p5"><span class="s1">cols:</span></p>
<p class="p5"><span class="s1">If no keys defined, first column is assumed to be the key.</span></p>
<p class="p5"><span class="s1">params:</span></p>
<p class="p5"><span class="s1">column=sql_code</span></p>
<p class="p5"><span class="s1">Define the SQL required to perform the selection</span></p>
<p class="p5"><span class="s1">_key=sql_code</span></p>
<p class="p5"><span class="s1">_key=column</span></p>
<p class="p5"><span class="s1">Define the SQL for the key. If this is a simple column name no explicit â€œ_keyâ€ will be created.</span></p>
<p class="p5"><span class="s1">_keys=column:column:...</span></p>
<p class="p5"><span class="s1">Define the key in terms of a list of columns.</span></p>
<p class="p5"><span class="s1">This uses the methods defined in st_server.</span></p>
<p class="p5"><span class="s1">Examples:</span></p>
<p class="p45"><span class="s1"><b>sql:///users?_key=login</b></span></p>
<p class="p5"><span class="s1">Pull in all the columns from â€œusersâ€, using login as the key.</span></p>
<p class="p45"><span class="s1"><b>sql:///users/login/password</b></span></p>
<p class="p5"><span class="s1">Pull in login and password from â€œusersâ€, using login as the key.</span></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Using an already opened speed table</span></p>
<p class="p45"><span class="s1">package require st_client</span></p>
<p class="p5"><span class="s1">name (no method)</span></p>
<p class="p5"><span class="s1">If the URI is not URI format, it assumes it's an object that provides stapi semantics already... typically a ctable, an already-opened ctable_client connection, or the result of a previous call to ::stapi::connect. It queries the object using the </span><span class="s7">methods</span><span class="s1"> command, and if necessary creates a wrapper around the ctable to implement the extra methods that STTP provides.</span></p>
<p class="p5"><span class="s1">Required methods to avoid the creation of a wrapper:</span></p>
<p class="p5"><span class="s1">key</span></p>
<p class="p5"><span class="s1">makekey</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">stapi::extend - the sttp API extensions to ctables</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">These extensions may be required for packages like STdisplay, but may not be provided by all speedtable-compatible packages, so ::stapi::extend can create a wrapper object when needed.</span></p>
<p class="p5"><span class="s1">::stapi::extend::connect object key-list ?-keysep string?</span></p>
<p class="p5"><span class="s1">This is also called internally by ::stapi::connect if the "-key" or "-keys" option is provided.</span></p>
<p class="p5"><span class="s1">If the _object_ was created by ::stapi::extend::connect, or if it can use the </span><span class="s7">methods</span><span class="s1"> call to determine that the object provides all the necessary methods, then the STAPI object is returned immediately. That makes it always safe to use this on an opened speedtable. but it can not be used to change the parameters of an existing STAPI object.</span></p>
<p class="p5"><span class="s1">Otherwise, this behaves identically to calling ::stapi::connect with the -key/-keys argument, and creates a wrapper object that understands at least the </span><span class="s7">key</span><span class="s1">, </span><span class="s7">makekey</span><span class="s1">, and </span><span class="s7">store</span><span class="s1"> methods.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>STDisplay - Speed Table Display Functions for the World Wide Web</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>10</span></p>
<p class="p54"><span class="s1"></span><br></p>
<p class="p34"><span class="s1">stDisplay - Display Functions for the WWW</span></p>
<p class="p5"><span class="s1">From the speed table API, <i>stDisplay</i>, speed table display functions for the world wide web.<span class="Apple-converted-space">Â  </span>This code is derived from Rivetâ€™s <b>diodisplay.tcl</b>.</span></p>
<p class="p59"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">set display [::STDisplay #auto ?-confvar value? ... \</span></p>
<p class="p29"><span class="s1"><span class="Apple-tab-span">	</span>-table table ?-keyfields key_list?]</span></p>
<p class="p50"><span class="s1"><span class="Apple-converted-space">Â  <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>or</span></p>
<p class="p30"><span class="s1">set display [::STDisplay #auto ?-confvar value? ... \</span></p>
<p class="p30"><span class="s1"><span class="Apple-tab-span">	</span>-uri uri]</span></p>
<p class="p49"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">One of </span><span class="s7">-table</span><span class="s1"> or </span><span class="s7">-uri</span><span class="s1"> must be provided.</span></p>
<p class="p5"><span class="s12">-table</span><span class="s1"> - use already opened table.</span></p>
<p class="p5"><span class="s1">If the table isn't STAPI-compatible it will use ::stapi::extend::connect to wrap it and in this case </span><span class="s7">keyfields</span><span class="s1"> must be provided.</span></p>
<p class="p5"><span class="s12">-uri</span><span class="s1"> - Use ::stapi::connect to connect to a ctable from a URI.</span></p>
<p class="p5"><span class="s1">Any valid STAPI URI can be used.</span></p>
<p class="p5"><span class="s1">Other config variables:</span></p>
<p class="p60"><span class="s1">-debug</span><span class="s13"> 0-9</span></p>
<p class="p5"><span class="s1">Set debug level</span></p>
<p class="p5"><span class="s12">-csvfile</span><span class="s1"> filename</span></p>
<p class="p5"><span class="s1">Name of CSV file to generate.</span></p>
<p class="p60"><span class="s1">-csvredirect</span><span class="s13"> ?0|1?</span></p>
<p class="p5"><span class="s1">If enabled, then the CSV file is downloaded immediately using a redirect.</span></p>
<p class="p5"><span class="s12">-key</span><span class="s1"> field_name</span></p>
<p class="p5"><span class="s1">Field to use as a key</span></p>
<p class="p5"><span class="s12">-title</span><span class="s1"> string</span></p>
<p class="p5"><span class="s1">Title of table.</span></p>
<p class="p5"><span class="s12">-arrows</span><span class="s1"> {up down}</span></p>
<p class="p5"><span class="s1">Symbols or HTML fragments to use for ascending and descending sort of a table column.</span></p>
<p class="p60"><span class="s1">-pagesize</span><span class="s13"> integer</span></p>
<p class="p5"><span class="s1">Number of rows displayed per page.</span></p>
<p class="p5"><span class="s12">-functions</span><span class="s1"> {Search List Add Edit Delete Details}</span></p>
<p class="p5"><span class="s1">Functions shown on the top of the display.</span></p>
<p class="p5"><span class="s12">-rowfunctions</span><span class="s1"> {Details Edit Delete}</span></p>
<p class="p5"><span class="s1">Functions shown at the end of the row.</span></p>
<p class="p46"><span class="s1"></span><br></p>
<p class="p24"><span class="s1">Methods for $display</span></p>
<p class="p53"><span class="s1"></span><br></p>
<p class="p5"><span class="s1">$display </span><span class="s12">show</span></p>
<p class="p5"><span class="s1">Render all HTML for the page. Destroys $display.</span></p>
<p class="p5"><span class="s1">$display </span><span class="s12">destroy</span></p>
<p class="p5"><span class="s1">Destroys $display</span></p>
<p class="p5"><span class="s1">$display </span><span class="s12">state</span></p>
<p class="p5"><span class="s1">Returns a list of name-value pairs that represent the current state of the query, as CGI variables, for populating external links. The counterpart to </span><span class="s12">hidden</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">functions</span><span class="s9"> </span><span class="s1">{?Add? ?Show? ...}</span></p>
<p class="p5"><span class="s1">Equivalent to the -functions configuration variable - enable global functions, to control the functions available in the search bar.<span class="Apple-converted-space">Â  </span>The possible functions are <i>Search</i>, <i>List</i>, <i>Add</i>, <i>Edit</i>, <i>Delete</i> and <i>Details</i>.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">rowfunctions</span><span class="s9"> </span><span class="s1">{?Edit? ?Delete? ...}</span></p>
<p class="p5"><span class="s1">Equivalent to the -rowfunctions configuration variable - enable row functions, to control the functions available in the search bar.<span class="Apple-converted-space">Â  </span>The possible functions are <i>Edit</i>, <i>Delete</i> and <i>Details</i>.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">field</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">?-configvar value?</span><span class="s9">...</span></p>
<p class="p5"><span class="s1">Define a field</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">alias</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">?field?</span></p>
<p class="p5"><span class="s1">Define an alias for an existing field. Aliases are used to create multiple filtered columns based on the same field.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">filter</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">?proc? ?columnâ€¦?</span></p>
<p class="p5"><span class="s1">Filter column <i>name</i> through [</span><span class="s7">proc</span><span class="s1"> $<i>value_of_field</i> ...] before displaying. If any </span><span class="s7">columns</span><span class="s1"> are provided the values of these columns will be appended to the filter.</span></p>
<p class="p45"><span class="s9">$display</span><span class="s14"> csvfilter</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">?proc? ?columnâ€¦?</span></p>
<p class="p5"><span class="s1">Filter column <i>name</i> through [proc $<i>value_of_field</i>] on generating a CSV file, like </span><span class="s12">filter</span><span class="s1">.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">unfilter</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">?proc?</span></p>
<p class="p5"><span class="s1">Filter entered text through [$proc text] before using to search table. This allows the user to enter (for example) a device name for a field that expects an IP address.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">order</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">$order</span></p>
<p class="p5"><span class="s1">Set sort order for field.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">case</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">$case</span></p>
<p class="p5"><span class="s1">Set whether the column can be matched uppercase or lowercase when doing a case-independent match.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">hovertext</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">$text</span></p>
<p class="p5"><span class="s1">Set text to be displayed when hovering the cursor over the title of the column.</span></p>
<p class="p45"><span class="s9">$display </span><span class="s14">blankval</span><span class="s9"> </span><span class="s1">name</span><span class="s9"> </span><span class="s1">$blank</span></p>
<p class="p5"><span class="s1">Value to treat as a null value and display as an empty cell.</span></p>
<p class="p5"><span class="s1">$display </span><span class="s12">limit</span><span class="s1"> $limit</span></p>
<p class="p5"><span class="s1">Set search terms to limit the displayed portion of the ctable. The limit is a list of {column_name value ?column_name value?â€¦}.</span></p>
<p class="p5"><span class="s1">$display </span><span class="s12">attributes</span><span class="s1"> name $attribute_list</span></p>
<p class="p5"><span class="s1">Set attributes (eg "bgcolor=blue") for field</span></p>
<p class="p5"><span class="s1">$display </span><span class="s12">hidden</span><span class="s1"> $cgivar $value</span></p>
<p class="p5"><span class="s1">This is used to pass any additional CGI variables the page will require through the links generated by STDisplay. This method may be invoked for each value</span></p>
<p class="p14"><span class="s1"></span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>C Code Generated and C Routines Created</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>11</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p34"><span class="s1">C Code Generated and C Routines Created</span></p>
<p class="p23"><span class="s1"></span><br></p>
<p class="p4"><span class="s1">This chapter describes internal implementation details of Speed Tables.<span class="Apple-converted-space">Â  </span>You can skip this section unless youâ€™re interested in finding out how Speed Tables work internally.</span></p>
<p class="p14"><span class="s1">(There is a better interface than this for all but the lowest-level access code.<span class="Apple-converted-space">Â  </span>You can interact with any speed table, regardless of its composition, by making standardized C calls via the speed tableâ€™s methods and speed tableâ€™s creator table structures.<span class="Apple-converted-space">Â  </span>It's not documented yet but you can study <b>speedtable_search.c</b>, where it is used extensively, and <b>speedtable.h</b>, where those structures are defined.)</span></p>
<p class="p14"><span class="s1">The row format is not guaranteed to be the same between point releases of speed tables.<span class="Apple-converted-space">Â  </span>However, fields you define will be accessible with the name you defined for them and of the data type corresponding to what you defined, regardless of the release, from the first version to the present and for the foreseeable future.</span></p>
<p class="p14"><span class="s1">For the above cable_info table defined, the following C struct is created:</span></p>
<p class="p30"><span class="s1">struct cable_info {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>TAILQ_ENTRY(cable_info)<span class="Apple-converted-space">Â  </span>_link;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct in_addr<span class="Apple-converted-space">Â  Â  Â  Â  </span>ip;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct ether_addr <span class="Apple-converted-space">Â  Â  </span>mac;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>char <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>*name;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>_nameLength;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>char <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>*address;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>_addressLength;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>char <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>*addressNumber;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>_addressNumberLength;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>char <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>*geos;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>_geosLength;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>i;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>j;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>long<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>ij;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct Tcl_Obj <span class="Apple-converted-space">Â  Â  Â  </span>*extraStuff;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_ipIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_macIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_nameIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_addressIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_addressNumberIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_geosIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_iIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_jIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_ijIsNull:1;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>unsigned int<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>_extraStuffIsNull:1;</span></p>
<p class="p29"><span class="s1">};</span></p>
<p class="p14"><span class="s1">Note that varstrings are <i>char *</i> pointers.<span class="Apple-converted-space">Â  </span>We allocate the space for whatever string is stored and store the address of that allocated space.<span class="Apple-converted-space">Â  </span>Fixed-length strings are generated inline.</span></p>
<p class="p5"><span class="s1">The null field bits and booleans are all generated together and should be stored efficiently by the compiler.<span class="Apple-converted-space">Â  </span>We rely on the C compiler to do the right thing with regards to word-aligning fields as needed for efficiency.</span></p>
<p class="p14"><span class="s1">You can examine the C code generated -- it's quite readable.<span class="Apple-converted-space">Â  </span>If you didn't know better, you might think it was written by a person rather than a program.<span class="Apple-converted-space">Â  </span>(Several times when working on speed tables Iâ€™ve started editing the generated code rather than the code thatâ€™s generating it, by mistake.)</span></p>
<p class="p14"><span class="s1">Each table-defining command created has a <i>CTableCreatorTable</i> associated with it, for example:</span></p>
<p class="p61"><span class="s1">struct CTableCreatorTable {</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_HashTable <span class="Apple-converted-space">Â  Â  </span>*registeredProspeed tablePtr;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>long unsigned int<span class="Apple-converted-space">Â  </span>nextAutoCounter;</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>nFields;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  </span>nLinkedLists;</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CONST char <span class="Apple-converted-space">Â  Â  Â  </span>**fieldNames;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Obj<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>**nameObjList;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  </span>*fieldList;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>enum ctable_types *fieldTypes;</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  </span>*fieldsThatNeedQuoting;</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct ctableFieldInfo **fields;</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>void *(*make_empty_row) ();</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*set) (Tcl_Interp *interp, struct CTableTable *ctable, Tcl_Obj *dataObj</span></p>
<p class="p61"><span class="s1">, void *row, int field, int indexCtl);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*set_null) (Tcl_Interp *interp, struct CTable *ctable, void *row,</span></p>
<p class="p61"><span class="s1">int field, int indexCtl);</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Obj *(*get) (Tcl_Interp *interp, void *row, int field);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CONST char *(*get_string) (const void *pointer, int field, int *lengthPtr, T</span></p>
<p class="p61"><span class="s1">cl_Obj *utilityObj);</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Obj *(*gen_list) (Tcl_Interp *interp, void *pointer);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Obj *(*gen_keyvalue_list) (Tcl_Interp *interp, void *pointer);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Obj *(*gen_nonnull_keyvalue_list) (Tcl_Interp *interp, void *pointer);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*lappend_field) (Tcl_Interp *interp, Tcl_Obj *destListObj, void *p, int</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â </span>field);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*lappend_field_and_name) (Tcl_Interp *interp, Tcl_Obj *destListObj, voi</span></p>
<p class="p61"><span class="s1">d *p, int field);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*lappend_nonnull_field_and_name) (Tcl_Interp *interp, Tcl_Obj *destList</span></p>
<p class="p61"><span class="s1">Obj, void *p, int field);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>void (*dstring_append_get_tabsep) (char *key, void *pointer, int *fieldNums,</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â </span>int nFields, Tcl_DString *dsPtr, int noKey);</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*search_compare) (Tcl_Interp *interp, struct CTableSearchStruct *search</span></p>
<p class="p61"><span class="s1">Control, void *pointer, int tailoredWalk);</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int (*sort_compare) (void *clientData, const void *hashEntryPtr1, const void</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â </span>*hashEntryPtr2);</span></p>
<p class="p63"><span class="s1">};</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">The registered proc table is how we handle registering methods, and the <i>nextAutoCounter</i> is how we can generate unique names for instances of the table when using "#auto".</span></p>
<p class="p14"><span class="s1"><i>nFields</i> is the number of fields defined for the row, while <i>nLinkedLists</i> says how many doubly linked lists are included in each row.<span class="Apple-converted-space">Â  </span>(The first doubly linked list is used by Speed Tables to link all rows of a table together; the rest are created for linking into index entries for each field that is defined as indexable.)</span></p>
<p class="p14"><span class="s1"><i>fieldNames</i> is a pointer to an array of pointers to the name of each field, while <i>nameObjList</i> is a pointer to an array of pointers of Tcl objects containing the names of each field.<span class="Apple-converted-space">Â  </span>By generating these once in the meta table, they can be used all over the place, by each speed table created by the meta table in many places, sharing these objects and neither incurring the memory or CPU overhead of constantly instantiating new Tcl objects from the name string whenever field names are needed.</span></p>
<p class="p14"><span class="s1"><i>fieldList</i> is a pointer to an array of integers corresponding to the field numbers.<span class="Apple-converted-space">Â  </span>Guess what?<span class="Apple-converted-space">Â  </span>If there are six fields it will contain {0, 1, 2, 3, 4, 5}.<span class="Apple-converted-space">Â  </span>The thing is we can feed it to routines we have that take such a list when the user has not told us what fields they want.<span class="Apple-converted-space">Â  </span><i>fieldTypes</i> are an array of data type numbers for each field.<span class="Apple-converted-space">Â  </span>(Data type numbers are defined in speed table.h.)<span class="Apple-converted-space">Â  </span><i>fieldsThatNeedQuoting</i> is an array of ints, one for each field, saying if it needs quoting or not.</span></p>
<p class="p5"><span class="s1">A number of the fields defined above are being consolidated into the <i>CTableFieldInfo struct</i>, which is defined for each field and contains the field name, name object, field number, type number, whether or not it needs quoting, its compare function (for indexing the the like, something we generate for each field), and its index number (which index of the array of doubly linked list elements built into each row), if indexed, else -1.</span></p>
<p class="p14"><span class="s1">Finally, a number of pointers to functions to do things to the speed table are defined.<span class="Apple-converted-space">Â  </span>This is cool stuff.<span class="Apple-converted-space">Â  </span>As I began to code the complex sorting and indexing code, it started getting hard to keep my head wrapped around it all.<span class="Apple-converted-space">Â  </span>Trying to custom-generate all that search code made complicated code even more complicated.<span class="Apple-converted-space">Â  </span>Standardizing the search code to not be custom generated at all and to access the custom-generated aspects of the different Speed Tables through these function pointers.</span></p>
<p class="p14"><span class="s1">Function pointers are provided to create an empty row, set a field of a row to a value, set a field of a row to null, get the native value of a field from a row as a Tcl object, and get a string representation of a field from a row.<span class="Apple-converted-space">Â  </span>Additional function pointers are provided to get the contents of a row as a Tcl list and as a key-value Tcl list, with or without null values, to append the contents of a field to a list, to append the name of a field and the contents of a rowâ€™s field to a list, and some other stuff like that.</span></p>
<p class="p14"><span class="s1">Each instance of the table created with "create" has a speedtableTable associated with it:</span></p>
<p class="p30"><span class="s1">struct CTableTable {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct CTableCreatorTable<span class="Apple-converted-space">Â  Â  Â  </span>*creatorTable;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_HashTable <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>*keyTablePtr;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>Tcl_Command<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>commandInfo;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>long <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>count;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>jsw_skip_t <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>**skipLists;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>struct ctable_baseRow<span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>*ll_head;</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>int<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>nLinkedLists;</span></p>
<p class="p29"><span class="s1">};</span></p>
<p class="p14"><span class="s1">This contains a pointer to the meta table (creatorTable), a hash table that we use to store and fetch keys, a command info struct that we use to delete our created command from the Tcl interpreter when it's told to destroy itself, the row count, a pointer to an array of pointers to skip lists, one for each field that has an index defined for it (itâ€™s NULL otherwise).</span></p>
<p class="p5"><span class="s1">A skip list for an indexed field can be walked to do a walk ordered by that field, as opposed to the pseudo-random ordering provided by walking the hash table or the last-thing-added-is-at-the-front ordering of â€œlinked list zeroâ€, the linked list that all rows in a table are in.</span></p>
<p class="p14"><span class="s1">Next, the number of fields is defined, the field names as an array of pointers to character strings and an enumerated type definition of the fields:</span></p>
<p class="p30"><span class="s1">#define CABLE_INFO_NFIELDS 10</span></p>
<p class="p30"><span class="s1">static CONST char *cable_info_fields[] = {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"ip",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"mac",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"name",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"address",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"addressNumber",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"geos",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"i",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"j",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"ij",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>"extraStuff",</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>(char *) NULL</span></p>
<p class="p30"><span class="s1">};</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">enum cable_info_fields {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_IP,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_MAC,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_NAME,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_ADDRESS,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_ADDRESSNUMBER,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_GEOS,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_I,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_J,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_IJ,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>FIELD_CABLE_INFO_EXTRASTUFF</span></p>
<p class="p30"><span class="s1">};</span></p>
<p class="p30"><span class="s1">The types of each field are emitted as an array and whether or not fields need quoting:</span></p>
<p class="p30"><span class="s1">enum ctable_types cable_info_types[] = {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_INET,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_MAC,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_VARSTRING,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_VARSTRING,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_VARSTRING,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_VARSTRING,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_INT,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_INT,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_LONG,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>CTABLE_TYPE_TCLOBJ</span></p>
<p class="p30"><span class="s1">};</span></p>
<p class="p47"><span class="s1"></span><br></p>
<p class="p30"><span class="s1">int cable_info_needs_quoting[] = {</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>1,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>1,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>1,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>1,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>0,</span></p>
<p class="p30"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>1</span></p>
<p class="p29"><span class="s1">};</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">A <i>setup routine</i> is defined that is automatically run once when the extension is loaded, for example, cable_info_setup creates some Tcl objects containing the names of all of the fields and stuff like that.</span></p>
<p class="p14"><span class="s1">An<i> init routine</i>, for example, cable_info_init, is defined that will set a newly malloc'ed row to default values (Defaults can be specified for most fields. If a field does not have a default, that fieldâ€™s null bit is set to true.)</span></p>
<p class="p5"><span class="s1">For efficiency's sake, we have a base copy that we initialize the first time the init routine is called and then for subsequent calls to initialize a row we merely do a structure copy to copy that base copy to the pointer to the row passed.</span></p>
<p class="p14"><span class="s1">A delete routine is defined, for instance, cable_info_delete, that will take a pointer to the defined structure and free it.<span class="Apple-converted-space">Â  </span>The thing here is that it has to delete any varstrings defined within the row prior to freeing the row itself.</span></p>
<p class="p14"><span class="s1"><b>*_find</b> takes a pointer to the StructTable corresponding to the speed table, for instance, cable_infoStructTable and a char * containing the key to be<span class="Apple-converted-space">Â  </span>looked up, and returns a pointer to the struct (in the example, a struct ctable_info *) containing the matching row, or NULL if none is found.</span></p>
<p class="p14"><span class="s1"><b>*_find_or_create</b> takes a pointer to the StructTable, a char * containing the key to be looked up or created, and a pointer to an int.<span class="Apple-converted-space">Â  </span>If the key is found, a pointer to its row is returned and the pointed-to int is set to zero.<span class="Apple-converted-space">Â  </span>If it is not found, a new entry for that name is created, an instance of the structure is allocated and initialized, the pointed-to int is set to one, and the pointer to the new row is returned.</span></p>
<p class="p14"><span class="s1">A <b>*_obj_is_null</b> routine is defined, for instance cable_info_obj_is_null that will return a 1 if the passed Tcl object contains a null value and zero otherwise.</span></p>
<p class="p14"><span class="s1"><b>*_genlist</b> (cable_info_genlist), given a pointer to a Tcl interpreter and a pointer to a row of the corresponding structure type will generate a list of all of the fields in the table into the Tcl interpreter's result object.</span></p>
<p class="p14"><span class="s1"><b>*_gen_keyvalue_list</b> does the same thing except includes the names of all the fields paired with the values.</span></p>
<p class="p14"><span class="s1"><b>*_gen_nonuull_keyvalue_list</b> does the same thing as *_gen_keyvalue_list except that any null values do not have their key-value pair emitted.</span></p>
<p class="p14"><span class="s1"><b>*_set</b> (cable_info_set) can be used from your own C code to set values in a row.<span class="Apple-converted-space">Â  </span>It takes a Tcl interpreter pointer, a pointer to a Tcl object containing the value you want to set, a pointer to the corresponding structure, and a field number from the enumerated list of fields.</span></p>
<p class="p14"><span class="s1">It handles detecting and setting the null bit as well.</span></p>
<p class="p14"><span class="s1"><b>*_set_fieldobj</b> is like *_set except the field name is contained in a Tcl object and that field name is extracted and looked up from the field list to determine the field number used by *_set.</span></p>
<p class="p14"><span class="s1"><b>*_set_null</b> takes a row pointer and a field number and sets the null bit for that field to true.<span class="Apple-converted-space">Â  </span>Note there is no way to set it to false except to set a value into a field as simply clearing the bit would be an error unless some value was written into the corresponding field.</span></p>
<p class="p14"><span class="s1"><b>*_get</b> fetches a field from a table entry and returns a Tcl object containing that field.<span class="Apple-converted-space">Â  </span>It takes a pointer to the Tcl interpreter, a pointer to a row of the structure, and a field number.<span class="Apple-converted-space">Â  </span>If the null bit is set, the null value is returned.</span></p>
<p class="p14"><span class="s1">Even though it is returning Tcl objects, it's pretty efficient as it passes back the same null object over and over for null values and uses the correct <b>Tcl_New*Obj</b> for the corresponding data type, hence ints are generated with <b>Tcl_NewIntObj</b>, varstrings with <b>Tcl_NewStringObj</b>, etc.</span></p>
<p class="p14"><span class="s1"><b>*_get_fieldobj</b> works like *_get except the field name is contained in the passed-in field object and looked up.</span></p>
<p class="p14"><span class="s1"><b>*_lappend_fieldobj</b> and <b>*_lappend_field_and_nameobj</b> append the specified field from the pointed-to row and append the field name (via a continually reused name object) and value, respectively.</span></p>
<p class="p14"><span class="s1"><b>*_lappend_nonull_field_and_nameobj</b> works just like *_lappend_field_and_nameobj except that it doesn't append anything when the specified field in the pointed-to row is null.</span></p>
<p class="p14"><span class="s1"><b>*_get_string</b> - This is particularly useful for the C coder.<span class="Apple-converted-space">Â  </span>It takes a pointer to an instance of the structure, a field number, a pointer to an integer, and a pointer to a Tcl object and returns a string representation of the requested field.<span class="Apple-converted-space">Â  </span>The Tcl object is used for certain conversions and hence can be considered a reusable utility object.<span class="Apple-converted-space">Â  </span>The length of the string returned is set into the pointed-to integer.</span></p>
<p class="p14"><span class="s1">Example:</span></p>
<p class="p29"><span class="s9"><span class="Apple-converted-space">Â  Â  </span></span><span class="s1">CONST char *cable_info_get_string (struct cable_info *cable_info_ptr, int field, int *lengthPtr, Tcl_Obj *utilityObj) {...}</span></p>
<p class="p14"><span class="s1">For fixed strings and varstrings, no copying is performed -- a pointer to the rowâ€™s string is returned.<span class="Apple-converted-space">Â  </span>Hence they must be considered to be constants by any of your code that retrieves them.</span></p>
<p class="p14"><span class="s1"><b>*_delete_all_rows</b> - give a pointer to the StructTable for an instance, delete all the rows.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Interfacing with Speed Tables From C</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>12</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Interfacing with Speed Tables From C</span></p>
<p class="p4"><span class="s1">This chapter explains the current state of interfacing with Speed Tables direc</span><span class="s15">tly</span><span class="s1"> from C.<span class="Apple-converted-space">Â  </span>You do not need to read this section unless youâ€™re interested in doing that.</span></p>
<p class="p14"><span class="s1">At the time of this writing, no C code has been written to use any of these routines that is not part of the Speed Table code itself.</span></p>
<p class="p14"><span class="s1">We envision providing a way to write C code inline within the Speed Table definition and, for more complicated code writing, to provide a way to compile and link your C code with the generated C code.</span></p>
<p class="p14"><span class="s1">In particular, generating search compare functions in native C, where you say something like</span></p>
<p class="p14"><span class="s1">if (row-&gt;severity &gt; 90 &amp;&amp; row-&gt;timeUnavailable &gt; 900) return 1;</span></p>
<p class="p14"><span class="s1">...and that gets compiled into a specifically invokable search that will be faster than our more general searches that arenâ€™t pre-compiled.</span></p>
<p class="p14"><span class="s1">This will require generating an include file containing the structure definition, function definitions for the C routines you'd be calling, and many other things currently going straight into the C code.<span class="Apple-converted-space">Â  </span>These changes are fairly straightforward, however, and are on the "to do" list.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Troubleshooting</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>13</span></p>
<p class="p16"><span class="s1">Troubleshooting</span></p>
<p class="p4"><span class="s1">This chapter describes what to do when speed tables doesnâ€™t work.</span></p>
<p class="p64"><span class="s1">Compiler Errors and Warnings When Building a Speed Table</span></p>
<p class="p14"><span class="s1">Speed Tables has been carefully coded to generate C code that will compile cleanly, specifically with the GNU C Compiler, gcc 3.3 and gcc 4.0.<span class="Apple-converted-space">Â  </span>Right now we run the compiler with error warning levels set very high and any warnings causing the speed tables library generation process to fail.<span class="Apple-converted-space">Â  </span>This has helped us to catch many bugs during development and weâ€™ve done the work to make sure all the routines are being used with correct argument types, etc.</span></p>
<p class="p14"><span class="s1">Should you come across a compiler warning that stops the speed table generation process, you may want to look at speed tablesâ€™ software and try to fix it.</span></p>
<p class="p14"><span class="s1">If you want to see what compiler commands speed tables is executing, you can turn on compiler debugging.</span></p>
<p class="p29"><span class="s1">set ::ctable::showCompilerCommands 1</span></p>
<p class="p14"><span class="s1">Do this after your â€œpackage require speedtableâ€ and before you declare your C extensions.</span></p>
<p class="p14"><span class="s1">How we invoke the compiler can be found in <b>gentable.tcl</b>.<span class="Apple-converted-space">Â  </span>We currently only support FreeBSD and Mac OS X, and a general solution will likely involve producing a GNU configure.in script and running autoconf, configure, etc.<span class="Apple-converted-space">Â  </span>Weâ€™d love some help on this.</span></p>
<p class="p24"><span class="s1">Simple Syntax Errors May Cause Compiler Errors</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">Most syntax errors in a C extension definition will be caught by speed tables and reported.<span class="Apple-converted-space">Â  </span>When sourcing a speed table definition, you may get the message</span></p>
<p class="p31"><span class="s1"><b>(run ::ctable::get_error_info to see speed table's internal errorInfo)</b></span></p>
<p class="p14"><span class="s1">This means that speed tables has caught some kind of unexpected internal error within itself.<span class="Apple-converted-space">Â  </span>It has suppressed its own error traceback because it isnâ€™t valuable to anyone who isnâ€™t looking to dig into the error.</span></p>
<p class="p14"><span class="s1">If youâ€™re not running tclsh interactively, youâ€™ll probably want to do so and then source in whatever is causing the error.<span class="Apple-converted-space">Â  </span>After you get the above error message, you can execute...</span></p>
<p class="p29"><span class="s1">::speedtable::get_error_info</span></p>
<p class="p14"><span class="s1">...to see what the commotion is about.</span></p>
<p class="p14"><span class="s1">A known bug in early December of 2006 is that if you define two fields in a table with the exact same name, youâ€™ll get a semi-strange traceback rather than a nice message telling you what you did.<span class="Apple-converted-space">Â  </span>Thatâ€™s kind of characteristic of what Iâ€™m talking about.</span></p>
<p class="p24"><span class="s1">Core Dumps at Runtime</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">Speed Tables shouldnâ€™t ever dump core but, if it does, you may want to try to figure it out.<span class="Apple-converted-space">Â  </span>If you want to be able to use your C debugger on the speed tables code, turn on compiler debugging after youâ€™ve loaded the speedtable package and before you load your extension.</span></p>
<p class="p29"><span class="s1">set ::ctable::genCompilerDebug 1</span></p>
<p class="p14"><span class="s1">Ideally youâ€™ll also build Tcl with debugging enabled.<span class="Apple-converted-space">Â  </span>When building Tcl, add </span><span class="s7">--enable-symbols</span><span class="s1"> to your configure options to get a Tcl library that you can run your debugger over.</span></p>
<p class="p14"><span class="s1">Run gdb on tclsh and when you hit your segmentation violation or whatever, if all is well, gdb should be on the line where the trap occurred and let you poke around all of the C variables and structures and the like.</span></p>
<p class="p14"><span class="s1">If gdb canâ€™t find any symbols, try moving up through some stack frames (see gdbâ€™s documentation for more information).<span class="Apple-converted-space">Â  </span>If in the speed tables routines you arenâ€™t getting file name and line number information and access to your local variables and the like, you probably havenâ€™t managed to build it with debugging enabled.<span class="Apple-converted-space">Â  </span>Turn on showing compiler commands and make sure you see <b>-g</b> being specified when the commands are being run.</span></p>
<p class="p14"><span class="s1">If you donâ€™t see the compiler being run, try deleting the contents of your build directory.<span class="Apple-converted-space">Â  </span>Thatâ€™ll trigger a regeneration and recompile of the speed table code for your extension.</span></p>
<p class="p2"><span class="s1"><span class="Apple-tab-span">	</span>Examples</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3"><span class="Apple-tab-span">	</span>14</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p16"><span class="s1">Examples</span></p>
<p class="p4"><span class="s1">This chapter contains numerous examples of using speed tables.</span></p>
<p class="p65"><span class="s1">Copy Speed Table Search Results to a Tab-Separated File</span></p>
<p class="p30"><span class="s1">tableType create t</span></p>
<p class="p30"><span class="s1">...</span></p>
<p class="p30"><span class="s1">set fp [open t.out w]</span></p>
<p class="p30"><span class="s1">t search -write_tabsep $fp</span></p>
<p class="p29"><span class="s1">close $fp</span></p>
<p class="p66"><span class="s9">This copies the entire table <b>t</b> to the file </span><span class="s8">t.out</span><span class="s9">.<span class="Apple-converted-space">Â  </span>Note that</span><span class="s1"> you could as easily have specified an open socket or any other sort of Tcl channel that might exist in place of the file.<span class="Apple-converted-space">Â  </span>You could restrict what gets copied using addition search options like </span><span class="s7">-compare {{&gt; severity 90}} -fields {name device severity}.</span></p>
<p class="p65"><span class="s1">Load a Speed Table using read_tabsep</span></p>
<p class="p30"><span class="s1">tableType create t</span></p>
<p class="p30"><span class="s1">set fp [open t.out r]</span></p>
<p class="p30"><span class="s1">t read_tabsep $fp</span></p>
<p class="p67"><span class="s1">close $fp</span></p>
<p class="p68"><span class="s1">Using Copy In For Super Fast Speed Table-to-PostgreSQL Transfers</span></p>
<p class="p14"><span class="s1">Here's the PostgreSQL syntax for copying from a file (or stdin) to a table:</span></p>
<p class="p14"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>COPY tablename [ ( column [, ...] ) ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>FROM { 'filename' | STDIN }</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span>[ [ WITH ]<span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  Â  </span>[ BINARY ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  Â  </span>[ OIDS ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  Â  </span>[ DELIMITER [ AS ] 'delimiter' ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  Â  </span>[ NULL [ AS ] 'null string' ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  Â  </span>[ CSV [ HEADER ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  </span>[ QUOTE [ AS ] 'quote' ]<span class="Apple-converted-space">Â </span></span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  </span>[ ESCAPE [ AS ] 'escape' ]</span></p>
<p class="p14"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">Â  Â  </span>[ FORCE NOT NULL column [, ...] ]</span></p>
<p class="p14"><span class="s1">Here's an example of taking a speed table and copying it it to a PostgreSQL table.</span></p>
<p class="p61"><span class="s7"><span class="Apple-converted-space">Â Â  </span></span><span class="s1">package require Pgtcl</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>source cpescan.ct</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>package require Cpe_scan</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>cpe_scan null_value \\N</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>cpe_scan create cpe</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set fp [open junk]</span></p>
<p class="p62"><span class="s1"><span class="Apple-converted-space">Â Â  Â </span></span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>cpe read_tabsep $fp</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>close $fp</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts [cpe count]</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set db [pg_connect www]</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># note double-backslashing on the null value and that we set the null value</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># to match the null_value set with the speed table.</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>set res [pg_exec $db "copy kfoo from stdin with delimiter as '\t' null as '\\\\N'"]</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># after you've started it, you expect the postgres response handle's status</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># to be PGRES_COPY_IN</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>if {[pg_result $res -status] != "PGRES_COPY_IN"} {</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>puts "[pg_result $res -status] - bailing"</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>puts "[pg_result $res -error]"</span></p>
<p class="p61"><span class="s1"><span class="Apple-tab-span">	</span>exit</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>}</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># next you use the write_tabsep method of the speed table to write<span class="Apple-converted-space">Â </span></span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># TO THE DATABASE HANDLE</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#cpe write_tabsep $db ip_address status ubr</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>cpe write_tabsep $db</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># then send a special EOF sequence.</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts $db "\\."</span></p>
<p class="p62"><span class="s1"></span><br></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># the result handle previously returned will now have magically changed</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span># its status to the normal PGRES_COMMAND_OK response.</span></p>
<p class="p61"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>#</span></p>
<p class="p63"><span class="s1"><span class="Apple-converted-space">Â  Â  </span>puts [pg_result $res -status]</span></p>
<p class="p15"><span class="s1"></span><br></p>
<p class="p14"><span class="s1">NOTE that all the records must be accepted by PostgreSQL, i.e. not violate any constraints, etc, or none of them will be.</span></p>
<p class="p14"><span class="s1">Karl Lehenbauer</span></p>
<p class="p14"><span class="s1">7/19/06 off-and-on through 1/07 and counting...</span></p>
<p class="p14"><span class="s1">(last edit March 11, 2008 2:38 PM)</span></p>
<p class="p14"><span class="s1">Acknowledgements</span></p>
<p class="p14"><span class="s1">I would like to acknowledge Peter da Silva, the first outside user of speed tables and the first person to use them in real production code with millions of rows of data.</span></p>
<p class="p14"><span class="s1">His insight and experience greatly contribute to the design and evolution of the technology.<span class="Apple-converted-space">Â  </span>In particular, thanks to him it is easier to use, more capable, faster, and more memory-efficient.</span></p>
<p class="p14"><span class="s1">Heâ€™s contributed a lot on the client/server side, making it possible to â€œfail overâ€ to a new server-side speed table definition in a very transparent way.</span></p>
<p class="p14"><span class="s1">In addition, the query optimizer was completely his idea and implementation.</span></p>
<p class="p69"><span class="s1"><sup>1 It is common to see ten or twenty times the space consumed by the data itself used up by the Tcl objects, lists, arrays, etc, used to hold them.<span class="Apple-converted-space">Â  </span>Even on a modern machine, using 20 gigabytes of memory to store a gigabyte of data is at a minimum kind of gross and, at worst, renders the solution unusable.)2 Additional data types can be added, although over Speed Tablesâ€™ evolution it has become an increasingly complicated undertaking.3<span class="Apple-converted-space">Â  </span>It feels a bit clumsy to have an external key like this, and we can pretty easily make the field be a part of the row itself, which seems better.<span class="Apple-converted-space">Â  </span>It has generally proven useful to have some kind of unique key for each row although we can and do synthesize our own and if weâ€™re willing to write it, explicitly support tables with no unique keys at all.4 Fairly analogous to stored procedures in a SQL database, Tcl code running on the serverâ€™s interpreter could perform multiple speed table actions in one invocation, reducing client/server communications overhead and any delays associated with it.</sup></span></p>
<p class="p1"><span class="s1"><span class="Apple-tab-span">	</span></span></p>
<p class="p70"><span class="s1">35</span></p>
<p class="p14"><span class="s1">36</span></p>
</body>
</html>
