// $Id$

// ctable table-specific function to delete all rows
//
// can be called with interp == NULL so it can be called from a Tcl
// command deletion callback, which doesn't have an interpreter handle
//
//
int ${table}_delete_all_rows(Tcl_Interp *interp, CTable *ctable, int final) {
    ctable_BaseRow           *row;
    ctable_BaseRow           *nextRow;

    // we say CTABLE_INDEX_FASTDELETE to cause the index entries
    // to not be deleted, drop all indexes later will do a
    // much faster job
    int indexCtl = CTABLE_INDEX_FASTDELETE;

    // DESTROY_SHARED is used with shared tables, does even less work than fastdelete
    // (we aren't using this)
    // int indexCtl = final ? CTABLE_INDEX_DESTROY_SHARED : CTABLE_INDEX_FASTDELETE;

#ifdef WITH_SHARED_TABLES
    // For a reader table, we just check that we're not doing something stupid
    // and return.
    if(ctable->share_type == CTABLE_SHARED_READER) {
	if(final) {
	    return TCL_OK;
	} else {
	    if (interp != NULL) {
		Tcl_AppendResult(interp, "Can't reset read-only shared table.", NULL);
		Tcl_SetErrorCode (interp, "speedtables", "read_only", NULL);
	    }
	    return TCL_ERROR;
	}
    }
#endif

    CTABLE_LIST_FOREACH_SAFE (ctable->ll_head, row, nextRow, 0) {

	// explicitly delete the hash entry - since we are fast-deleting
	// the hash table buckets and not updating all the links, we
	// gotta free key strings here or they don't get freed.  slight kludge.
	// gotta do it before ${table}_delete because afterwards, the row
	// is already deleted.

	// Remove the freed key, because it *is* possible for a private table
	// to have a valid key. Alternatively, we could remove this free and
	// depend on ${table}_delete doing it.
#ifdef WITH_SHARED_TABLES
	if(ctable->share_type == CTABLE_SHARED_MASTER) {
	    if(!final)
	        shmfree(ctable->share, row->hashEntry.key);
	} else
#endif
            ckfree (row->hashEntry.key);
	row->hashEntry.key = NULL;

	${table}_delete(ctable, (struct ${table} *)row, indexCtl);
    }

    // reset the linked list of all rows
    ctable_ListInit (&ctable->ll_head, __FILE__, __LINE__);

    ctable_DeleteHashTable (ctable->keyTablePtr);

    // drop all indexes, if any
    ctable_DropAllIndexes (ctable, final);

    ctable->count = 0;
    ctable->autoRowNumber = 0;
    ctable->destroying = 0;

    return TCL_OK;
}

// function to destroy a ctable
//
// can be called with interp == NULL so it can be called from a
// Tcl command deletion callback, which doesn't have an interpreter handle
//
int ${table}_destroy_ctable (Tcl_Interp *interp, CTable *ctable)
{
    if (${table}_delete_all_rows (interp, ctable, 1) != TCL_OK) {
	end_write(ctable);
	return TCL_ERROR;
    }

    LIST_REMOVE (ctable, instance);

    if (interp != NULL) {
	// mark that we're already destorying the ctable so that the
	// delete callback will know not to recursively call us.
	//
	// this could occur when the "destroy" method is invoked,
	// but we don't want to just invoke Tcl_DeleteCommandFromToken
	// there as the call to ${table}_destroy_ctable could fail
	// and we want to return that failure if we can.
	// (If we're invoked because of a rename to {} or deletion
	// of the interpreter, we have no ability to return an error)

	ctable->destroying = 1;
	Tcl_DeleteCommandFromToken (interp, ctable->commandInfo);
    }

#ifdef WITH_SHARED_TABLES
    // We'll never need "ctable" again, so now we can trash it.
    // And, possibly, unmap the file
    if(ctable->share) {
	// abandon reservation for name
	release_name(ctable->share, ctable->share_name);

	// unmap file (if all reservations abandoned)
	doDetach(interp, ctable->share);
    }
#endif

    // return here so we don't risk touching ctable again.
    return TCL_OK;
}

// delete proc for Tcl so that renaming a ctable to "" and/or deleteing
// an interpreter will cause the table to be destroyed
//
void ${table}_cmdDeleteProc (ClientData clientData)
{
    CTable *ctable = (CTable *)clientData;

    // if we're not in the middle of destroying the ctable, destroy it,
    // else do nothing
    if (!ctable->destroying) {
	${table}_destroy_ctable (NULL, ctable);
    }
}

// Forward definition
int ${table}MetaObjCmd(ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]);

int ${table}ObjCmd (ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    CTable *ctable = (CTable *)cData;
    struct $table *row;
    int optIndex;
    ctable_HashEntry *hashEntry;
    Tcl_HashEntry *registeredProcHashEntry;
    int indexCtl;
    int commandStatus = TCL_OK;

    static CONST char *options[] = {"get", "set", "store", "incr", "array_get", "array_get_with_nulls", "exists", "delete", "count", "batch", "search", "search+", "type", "import_postgres_result", "fields", "field", "fieldtype", "needs_quoting", "names", "reset", "destroy", "statistics", "read_tabsep", "write_tabsep", "index", "foreach", "key", "makekey", "methods", "attach", "getprop", "share", "null", "isnull", "verify", (char *)NULL};

    enum options {OPT_GET, OPT_SET, OPT_STORE, OPT_INCR, OPT_ARRAY_GET, OPT_ARRAY_GET_WITH_NULLS, OPT_EXISTS, OPT_DELETE, OPT_COUNT, OPT_BATCH, OPT_SEARCH, OPT_SEARCHPLUS, OPT_TYPE, OPT_IMPORT_POSTGRES_RESULT, OPT_FIELDS, OPT_FIELD, OPT_FIELDTYPE, OPT_NEEDSQUOTING, OPT_NAMES, OPT_RESET, OPT_DESTROY, OPT_STATISTICS, OPT_READ_TABSEP, OPT_WRITE_TABSEP, OPT_INDEX, OPT_FOREACH, OPT_KEY, OPT_MAKEKEY, OPT_METHODS, OPT_ATTACH, OPT_GETPROP, OPT_SHARE, OPT_NULL, OPT_ISNULL, OPT_VERIFY, NUM_OPTIONS
		};

#ifdef WITH_SHARED_TABLES
    // Options allowed in shared tables
    static enum options shared_options[] = { OPT_METHODS, OPT_DESTROY, OPT_NEEDSQUOTING, OPT_FIELDTYPE, OPT_FIELD, OPT_FIELDS, OPT_TYPE, OPT_SEARCHPLUS, OPT_SEARCH, OPT_GETPROP, OPT_SHARE, NUM_OPTIONS };
    static int shared_ok[NUM_OPTIONS] = {-1};

    // Read_only options
    static enum options readonly_options[] = { OPT_GET, OPT_ARRAY_GET, OPT_ARRAY_GET_WITH_NULLS, OPT_EXISTS, OPT_COUNT, OPT_SEARCH, OPT_SEARCHPLUS, OPT_TYPE, OPT_FIELDS, OPT_FIELD, OPT_FIELDTYPE, OPT_NEEDSQUOTING, OPT_NAMES, OPT_STATISTICS, OPT_WRITE_TABSEP, OPT_FOREACH, OPT_KEY, OPT_MAKEKEY, OPT_METHODS, OPT_GETPROP, NUM_OPTIONS };
    static int readonly[NUM_OPTIONS] = {-1};

    // Memory_allocating options - except for "index create" which
    // has to be checked for explicitly.
    static enum options shmcheck_options[] = {OPT_SET, OPT_STORE, OPT_INCR, OPT_BATCH, OPT_SEARCH, OPT_SEARCHPLUS, OPT_IMPORT_POSTGRES_RESULT, OPT_WRITE_TABSEP, NUM_OPTIONS };
    static int shmcheck[NUM_OPTIONS] = {-1};

    // First time through, make it a bitmap.
    if(shared_ok[0] == -1) {
	int i;
	for(i = 0; i < NUM_OPTIONS; i++) {
	    shared_ok[i] = FALSE;
	    readonly[i] = FALSE;
	    shmcheck[i] = FALSE;
	}
	for(i = 0; shared_options[i] != NUM_OPTIONS; i++)
	    shared_ok[shared_options[i]] = TRUE;
	for(i = 0; readonly_options[i] != NUM_OPTIONS; i++)
	    readonly[readonly_options[i]] = TRUE;
	for(i = 0; shmcheck_options[i] != NUM_OPTIONS; i++)
	    shmcheck[shmcheck_options[i]] = TRUE;
    }
#endif

    if (objc == 1) {
        Tcl_WrongNumArgs (interp, 1, objv, "option ?args?");
	return TCL_ERROR;
    }

    // If it's not a known option, look for registered methods and run one if found
    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
	Tcl_Obj      **calloutObjv;
	int           i;
	int           result;

	registeredProcHashEntry = Tcl_FindHashEntry (ctable->creator->registeredProcTablePtr, Tcl_GetString (objv[1]));

	//  Not on option or method, return error
	if (registeredProcHashEntry == (Tcl_HashEntry *) NULL) {
	    Tcl_HashSearch hashSearch;

	    Tcl_AppendResult (interp, ", or one of the registered methods:", (char *)NULL);

	    for (registeredProcHashEntry = Tcl_FirstHashEntry (ctable->creator->registeredProcTablePtr, &hashSearch); registeredProcHashEntry != (Tcl_HashEntry *) NULL; registeredProcHashEntry = Tcl_NextHashEntry (&hashSearch)) {
	        char *key = Tcl_GetHashKey (ctable->creator->registeredProcTablePtr, registeredProcHashEntry);
		Tcl_AppendResult (interp, " ", key, (char *)NULL);
	    }
	    return TCL_ERROR;
	}

        // perform registered method and return the result
	calloutObjv = (Tcl_Obj **)ckalloc (sizeof (Tcl_Obj *) * objc);
	calloutObjv[0] = (Tcl_Obj *)Tcl_GetHashValue (registeredProcHashEntry);
	calloutObjv[1] = objv[0];
	for (i = 2; i < objc; i++) {
	    calloutObjv[i] = objv[i];
	}
	result = Tcl_EvalObjv (interp, objc, calloutObjv, 0);
	ckfree ((void *)calloutObjv);
	return result;
    }

    // fall through to primitives

#ifdef WITH_SHARED_TABLES
    if (ctable->share_type == CTABLE_SHARED_READER) {
        if (!shared_ok[optIndex]) {
	    Tcl_AppendResult (interp, "Command '", options[optIndex], "' is not possible in a shared reader table.", (char *)NULL);
	    Tcl_SetErrorCode (interp, "speedtables", "read_only", NULL);
	    return TCL_ERROR;
        }
    } else if(ctable->share_type == CTABLE_SHARED_MASTER && ctable->share) {
	// If this might allocate shared memory
	if(shmcheck[optIndex]) {
	    // Check for free space
	    if(shmfreemem(ctable->share, 0) < ctable->share_min_free) {
		Tcl_AppendResult (interp, "Free shared memory low.", NULL);
		Tcl_SetErrorCode (interp, "speedtables", "shared_memory_low", NULL);
		return TCL_ERROR;
	    }
	}
	// If this might modify the table...
	if(!readonly[optIndex]) {
	    // Inform the shared memory code that a write is starting
	    begin_write(ctable);
	}
    }
#endif

    switch ((enum options) optIndex) {
      case NUM_OPTIONS: { // Can't happen!
	  Tcl_AppendResult (interp, "Can't happen.", (char *)NULL);
	  return TCL_ERROR;
      }

      case OPT_TYPE: {
	  if(objc==2)
              Tcl_SetObjResult (interp, Tcl_NewStringObj ("$table", -1));
	  else
	      commandStatus = ${table}MetaObjCmd(cData, interp, objc-1, objv+1);

	  break;
      }

      // Return various static bits of information about the ctable, for
      // reflection. Really supercedes "type".
      case OPT_GETPROP: {
	  Tcl_Obj           *list = Tcl_NewObj();
	  Tcl_Obj	    *tmpobj;
	  static CONST char *infoStrings[] = { "type", "$table", "extension", "$extension", "key", "$keyFieldName", "quote", "", NULL };
	  int	             i;
	  int                j;

	  if(objc == 2) {
	      for(i = 0; infoStrings[i]; i++) {
		  tmpobj = infoStrings[i][0]
			 ? Tcl_NewStringObj(infoStrings[i], -1)
			 : ctable_quoteTypeList(interp);

		  if (Tcl_ListObjAppendElement (interp, list, tmpobj) == TCL_ERROR) {
		      Tcl_AppendResult(interp, " (internal error)", NULL);
		      return TCL_ERROR;
		  }
	      }
	  } else {
	      for(j = 2; j < objc; j++) {
    		  if (Tcl_GetIndexFromObj (interp, objv[j], infoStrings, "property", TCL_EXACT, &i) != TCL_OK || (i & 1)) {
		      Tcl_ResetResult(interp); // Because it's misleading
		      Tcl_AppendResult(interp, "Unknown property '", Tcl_GetString(objv[j]), "'.", NULL);
		      Tcl_SetErrorCode (interp, "speedtables", "unknown_property", NULL);
		      return TCL_ERROR;
		  }
		  tmpobj = infoStrings[i+1][0]
			 ? Tcl_NewStringObj(infoStrings[i+1], -1)
                         : ctable_quoteTypeList(interp);
		  if (Tcl_ListObjAppendElement (interp, list, tmpobj) == TCL_ERROR) {
		      Tcl_AppendResult(interp, " (internal error)", NULL);
		      return TCL_ERROR;
		  }
	      }
	  }
	  Tcl_SetObjResult (interp, list);
	  break;
      }

      case OPT_FIELDS: {
          int i;

	  Tcl_Obj *obj;
	  Tcl_Obj *resultObj = Tcl_GetObjResult(interp);

	  if (objc != 2) {
	    Tcl_WrongNumArgs (interp, 2, objv, NULL);
	    return TCL_ERROR;
	  }

	  for (i = 0; (obj = ${table}_NameObjList[i]) != NULL; i++) {
	      if (!is_hidden_obj(obj) && Tcl_ListObjAppendElement (interp, resultObj, obj) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  break;
      }

      // return the key
      case OPT_KEY: {
	  Tcl_SetObjResult (interp, ${table}_NameObjList[${table}_keyField]);
	  break;
      }

      case OPT_METHODS: {
          int i;

	  Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
	  Tcl_HashSearch hashSearch;

	  if (objc != 2) {
	      Tcl_WrongNumArgs (interp, 2, objv, NULL);
	      return TCL_ERROR;
	  }

	  for (i = 0; options[i] != NULL; i++) {
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (options[i], -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  for (registeredProcHashEntry = Tcl_FirstHashEntry (ctable->creator->registeredProcTablePtr, &hashSearch); registeredProcHashEntry != (Tcl_HashEntry *) NULL; registeredProcHashEntry = Tcl_NextHashEntry (&hashSearch)) {
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (Tcl_GetHashKey (ctable->creator->registeredProcTablePtr, registeredProcHashEntry), -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  break;
      }

      case OPT_FIELD: {
	static CONST char *subOptions[] = {"getprop", "properties", "proplist", (char *)NULL};
	int                      suboptIndex;
	int                      fieldNum;
	int                      propIndex;
        ctable_FieldInfo        *f;
      Tcl_Obj                   *resultObj = Tcl_GetObjResult (interp);

	enum suboptions {SUBOPT_GETPROP, SUBOPT_PROPERTIES, SUBOPT_PROPLIST};

	if ((objc < 4) || (objc > 5)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "fieldName opt ?arg?");
	    return TCL_ERROR;
	}

        if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
	  return TCL_ERROR;
        }

	if (Tcl_GetIndexFromObj (interp, objv[3], subOptions, "suboption", TCL_EXACT, &suboptIndex) != TCL_OK) {
	    return TCL_ERROR;
	}

        f = ctable->creator->fields[fieldNum];

	switch (suboptIndex) {

	  case SUBOPT_GETPROP: {
	    if (objc != 5) {
	      Tcl_WrongNumArgs (interp, 3, objv, "fieldName propName");
	      return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[4], (CONST char **)f->propKeys, "property", TCL_EXACT, &propIndex) != TCL_OK) {
	        return TCL_ERROR;
	    }

	    Tcl_SetStringObj (resultObj, f->propValues[propIndex], -1);
	    return TCL_OK;
	  }

	  case SUBOPT_PROPERTIES: {
	      int i;

	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      for (i = 0; f->propKeys[i] != NULL; i++) {
		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propKeys[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
		  }
	      }

	      return TCL_OK;
	  }

	  case SUBOPT_PROPLIST: {
	      int i;

	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      for (i = 0; f->propKeys[i] != NULL; i++) {
		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propKeys[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
	          }

		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propValues[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
	          }
	      }
	      return TCL_OK;
	  }
        }
	panic ("\"impossible\" path followed");
      }

      case OPT_FIELDTYPE: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetStringObj (Tcl_GetObjResult (interp), ctableTypes[(int)${table}_types[fieldIndex]], -1);
	  break;
      }

      case OPT_NEEDSQUOTING: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), ${table}_needs_quoting[fieldIndex]);
	  break;
      }

      // Call the "Shared" Extension's "share" command to do the work
      // Our command line is "ctable 'share' cmd ?args?"
      // We want to make it "'share' cmd sharename ?args?"
      case OPT_SHARE: {
#ifdef WITH_SHARED_TABLES
	  Tcl_Obj **newObjv = (Tcl_Obj **)ckalloc(sizeof (Tcl_Obj *) * objc);
	  int       i;
	  int       result;

	  if (objc < 3) {
              Tcl_WrongNumArgs (interp, 2, objv, "cmd ?args?");
	      return TCL_ERROR;
	  }

	  if(!ctable->share) {
	      Tcl_AppendResult (interp, "Shared commands not available on this table.", (char *)NULL);
	      return TCL_ERROR;
	  }

	  newObjv[0] = objv[1];		// 'share'
	  newObjv[1] = objv[2];		// cmd
	  newObjv[2] = Tcl_NewObj();	// empty sharename
	  for(i = 3; i < objc; i++)	// ?args?
	      newObjv[i] = objv[i];

	  // And since the sharename is null, we pass the share in cData.
	  result = shareCmd((ClientData)ctable->share, interp, objc, newObjv);

	  ckfree((void *)newObjv);

	  return result;
#else
	  Tcl_AppendResult (interp, "Shared support not enabled.", (char *)NULL);
	  Tcl_SetErrorCode (interp, "speedtables", "no_shared_support", NULL);
	  return TCL_ERROR;
#endif
      }

      case OPT_STATISTICS: {
          CONST char *stats = ctable_HashStats (ctable->keyTablePtr);
	  Tcl_SetStringObj (Tcl_GetObjResult (interp), stats, -1);
	  ckfree ((void *)stats);
	  break;
      }

      case OPT_BATCH: {
	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "batchList");
	    return TCL_ERROR;
	}

	commandStatus = ctable_RunBatch (interp, ctable, objv[0], objv[2]);
	break;
      }

      case OPT_SEARCH:
      case OPT_SEARCHPLUS: {
	commandStatus = ctable_SetupAndPerformSearch (interp, objv, objc, ctable, CTABLE_SEARCH_INDEX_ANY);
	break;
      }

      case OPT_NAMES: {
          Tcl_Obj           *resultObj = Tcl_GetObjResult (interp);
	  ctable_HashSearch  hashSearch;
	  char              *pattern = (char *) NULL;
	  char              *key;

	  if (objc > 3) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName codeBody ?pattern?");
	      return TCL_ERROR;
	  }

	  if (objc == 3) {
	      pattern = Tcl_GetString (objv[2]);
	  }

	  for (hashEntry = ctable_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (ctable_HashEntry *) NULL; hashEntry = ctable_NextHashEntry (&hashSearch)) {
	      key = hashEntry->key;
	      if ((pattern != (char *) NULL)  && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (key, -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }
	  break;
      }

      case OPT_RESET: {
	  if (${table}_delete_all_rows (interp, ctable, 0) != TCL_OK) {
	      return TCL_ERROR;
	  }
	  ctable_InitHashTable (ctable->keyTablePtr);
	  break;
      }

      case OPT_DESTROY: {
	  return ${table}_destroy_ctable (interp, ctable);
      }

      case OPT_ATTACH: {
#ifdef WITH_SHARED_TABLES
	  if (ctable->share_type == CTABLE_SHARED_MASTER) {
	      int	 pid = -1;
	      Tcl_Obj	*resultObj = Tcl_GetObjResult(interp);
	      char	*resultList[4];
	      int	 i;

	      if (objc != 3) {
	          Tcl_WrongNumArgs (interp, 2, objv, "process_id");
		  return TCL_ERROR;
	      }
	      if (Tcl_GetIntFromObj (interp, objv[2], &pid) == TCL_ERROR) {
		  Tcl_AppendResult(interp, " parsing process id", NULL);
		  return TCL_ERROR;
	      }

	      if (!shmattachpid(ctable->share, pid)) {
		  TclShmError(interp, Tcl_GetString(objv[2]));
		  return TCL_ERROR;
	      }

	      resultList[0] = "file";
	      resultList[1] = ctable->share_file;
	      resultList[2] = "name";
	      resultList[3] = ctable->share_name;

	      for(i = 0; i < 4; i++) {
	          if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (resultList[i], -1)) == TCL_ERROR) {
		      return TCL_ERROR;
	          }
	      }

	      break;
	  }
#endif
	  Tcl_AppendResult(interp, "Not a shared table.\n", NULL);
	  Tcl_SetErrorCode (interp, "speedtables", "not_a_shared_table", NULL);
	  return TCL_ERROR;
      }

      case OPT_DELETE: {
	if(ctable->searching) {
	    Tcl_AppendResult(interp, "Can not delete from inside search.\n", NULL);
	    Tcl_SetErrorCode (interp, "speedtables", "no_delete_inside_search", NULL);
	    return TCL_ERROR;
	}

	if (objc != 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "field");
	    return TCL_ERROR;
	}
	hashEntry = ctable_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (ctable_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	    break;
	}

	row = (struct $table *) hashEntry;

	${table}_delete(ctable, row, CTABLE_INDEX_NORMAL);
	ctable->count--;
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	break;
      }

      case OPT_COUNT: {
	  if (objc != 2) {
	      Tcl_WrongNumArgs (interp, 2, objv, NULL);
	      return TCL_ERROR;
	  }
          Tcl_SetIntObj (Tcl_GetObjResult (interp), ctable->count);
	  break;
      }

      case OPT_EXISTS: {
	if (objc != 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "field");
	    return TCL_ERROR;
	}
	hashEntry = ctable_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (ctable_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	} else {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	}
	break;
      }

      case OPT_MAKEKEY:
      case OPT_STORE: {
        int            i;
	int            listObjc;
	Tcl_Obj      **listObjv;
	char	      *key;
        Tcl_Obj       *keyObj;
	static char    keyString[32];
	int	       nocomplain = 0;
	Tcl_Obj *CONST*origObjv = objv;

	while (objc > 2) {
	    char *option = Tcl_GetString (objv[2]);
	    if(*option != '-') break;
	    if (strcmp (option, "-nocomplain") == 0) {
	        nocomplain = 1;
	    } else {
		Tcl_AppendResult(interp, "Unknown option ", option, NULL);
		return TCL_ERROR;
	    }
	    objv++;
	    objc--;
	}

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, origObjv, "?-nocomplain? pairList or ?-nocomplain? field value ?field value...?");
	    return TCL_ERROR;
	}

	if (objc == 3) {
	    // If there's precisely one element in the list, get a new list
	    // vector from the first element
	    if (Tcl_ListObjGetElements (interp, objv[2], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	} else {
	    // new list vector is the old list vector
	    listObjc = objc - 2;
	    listObjv = (Tcl_Obj **)objv + 2;
	}

	if ((listObjc % 2) != 0) {
	    Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
	    return TCL_ERROR;
	}

	keyObj = ${table}_key_from_keylist(interp, listObjv, listObjc);

	if(optIndex == OPT_MAKEKEY) {
	    if(!keyObj) {
	        Tcl_AppendResult (interp, "Key not found in list", (char *)NULL);
		return TCL_ERROR;
	    }
	    Tcl_SetObjResult (interp, keyObj);
	    break;
	}

	if(keyObj) {
	    key = Tcl_GetString(keyObj);
	} else {
	    sprintf(key = keyString, "%u", ctable->autoRowNumber++);
        }

        row = ${table}_find_or_create (interp, ctable, key, &indexCtl);
	if(!row) {
	    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	    return TCL_ERROR;
	}

	for (i = 0; i < listObjc; i+= 2) {
	    if (${table}_set_fieldobj (interp, ctable, listObjv[i+1], row, listObjv[i], indexCtl, nocomplain) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	}

        if (indexCtl == CTABLE_INDEX_NEW)
	    if (${table}_index_defaults(interp, ctable, row) == TCL_ERROR)
	        return TCL_ERROR;

        Tcl_SetObjResult (interp, Tcl_NewStringObj (key, -1));

	break;
      }

      case OPT_SET: {
        int            i;
	int            listObjc;
	Tcl_Obj      **listObjv;
	Tcl_Obj       *keyObj = objv[2];
	int	       nocomplain = 0;
	Tcl_Obj *CONST*origObjv = objv;

	while (objc > 3) {
	    char *option = Tcl_GetString (objv[3]);
	    if(*option != '-') break;
	    if (strcmp (option, "-nocomplain") == 0) {
	        nocomplain = 1;
	    } else {
		Tcl_AppendResult(interp, "Unknown option ", option, NULL);
		return TCL_ERROR;
	    }
	    objv++;
	    objc--;
	}

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, origObjv, "key ?-nocomplain? pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (interp, ctable, Tcl_GetString (keyObj), &indexCtl);
	if(!row) {
	    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	    return TCL_ERROR;
	}

	if (objc == 4) {
	    // If there's precisely one element in the list, get a new list
	    // vector from the first element
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	} else {
	    // new list vector is the old list vector
	    listObjc = objc - 3;
	    listObjv = (Tcl_Obj **)objv + 3;
	}

	if ((listObjc % 2) != 0) {
	    Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
	    return TCL_ERROR;
	}

	for (i = 0; i < listObjc; i+= 2) {
	    if (${table}_set_fieldobj (interp, ctable, listObjv[i+1], row, listObjv[i], indexCtl, nocomplain) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	}

        if (indexCtl == CTABLE_INDEX_NEW)
	    if (${table}_index_defaults(interp, ctable, row) == TCL_ERROR)
	        return TCL_ERROR;

	break;
      }

      case OPT_INCR: {
        int       i;
	int       listObjc;
	Tcl_Obj **listObjv;

	if ((objc < 3) || ((objc != 4) && (objc % 2) != 1)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (interp, ctable, Tcl_GetString (objv[2]), &indexCtl);
	if(!row) {
	    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	    return TCL_ERROR;
	}

	if (objc == 4) {
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }

	    if ((listObjc % 2) != 0) {
		Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
		return TCL_ERROR;
	    }

	    for (i = 0; i < listObjc; i+= 2) {
		int field;

		if (Tcl_GetIndexFromObj (interp, listObjv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		    return TCL_ERROR;
		}

		if (${table}_incr (interp, ctable, listObjv[i+1], row, field, indexCtl) == TCL_ERROR) {
		    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		    return TCL_ERROR;
		} else {

		    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
			Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
			return TCL_ERROR;
		    }
		}
	    }

            if (indexCtl == CTABLE_INDEX_NEW)
	        if (${table}_index_defaults(interp, ctable, row) == TCL_ERROR)
	            return TCL_ERROR;

	    break;
	}

	for (i = 3; i < objc; i += 2) {
	    // printf ("i = %d\n", i);
	    int field;

	    if (Tcl_GetIndexFromObj (interp, objv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (${table}_incr (interp, ctable, objv[i+1], row, field, indexCtl) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	        return TCL_ERROR;
	    }

	    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
		return TCL_ERROR;
	    }
	}

        if (indexCtl == CTABLE_INDEX_NEW)
	    if (${table}_index_defaults(interp, ctable, row) == TCL_ERROR)
	        return TCL_ERROR;

        break;
      }

      case OPT_IMPORT_POSTGRES_RESULT: {
#ifdef WITH_PGTCL
          const PGresult   *res;
	  char             *fieldName = NULL;
	  char             *key = NULL;
	  char             *value;
	  int              *fieldList;
	  int               fieldIndex;
	  int               nFields;
	  int               nTuples;
	  int               field;
	  int               noKeys = 0;
	  int               pgRow;
	  Tcl_Obj          *fieldNameObj = Tcl_NewObj();
	  Tcl_Obj          *valueObj;
	  Tcl_Obj          *utilityObj = Tcl_NewObj();
	  char              keyNumberString[32];
	  int		    keyColumn;
	  int		    firstColumn;
	  int		    nocomplain = 0;
	  Tcl_Obj	   *resultObj = objv[2];
	  int		    poll_interval = 0;
	  int		    poll_counter = 0;
	  Tcl_Obj	   *poll_code = NULL;
	  int		    poll_foreground = 0;

	  extern PGresult *PgGetResultId (Tcl_Interp *interp, CONST char *id, void **resultidPtr);

	  int               i = 3;

          if (objc < 3) {
	    import_arg_err:
	      Tcl_WrongNumArgs (interp, 2, objv, "pgTclResultHandle ?-nokeys? ?-nocomplain? ?-poll_code codeBody? ?-poll_interval rate?");
	      return TCL_ERROR;
	  }

	  while (i < objc) {
	      char *option = Tcl_GetString (objv[i++]);
	      if (strcmp (option, "-nokeys") == 0) {
	          noKeys = 1;
	      } else if (strcmp (option, "-nocomplain") == 0) {
		  nocomplain = 1;
	      } else if (strcmp (option, "-foreground") == 0) {
		  poll_foreground = 1;
	      } else if (strcmp (option, "-poll_code") == 0) {
	          if (i >= objc)
		      goto import_arg_err;
		  if (poll_interval == 0)
		      poll_interval = CTABLE_DEFAULT_POLL_INTERVAL;
		  poll_code = objv[i++];
	      } else if (strcmp (option, "-poll_interval") == 0) {
	          if (i >= objc)
		      goto import_arg_err;
		  if (Tcl_GetIntFromObj(interp, objv[i++], &poll_interval) == TCL_ERROR) {
		      Tcl_AppendResult (interp, "in argument to -poll_interval", NULL);
		      return TCL_ERROR;
		  }
	      } else {
	          goto import_arg_err;
	      }
	  }

	  if (poll_code != NULL && poll_interval == 0) {
	      Tcl_AppendResult (interp, "-poll_code specified but -poll_interval set to 0", NULL);
	      return TCL_ERROR;
	  }

	  res = PgGetResultId (interp, Tcl_GetString (resultObj), NULL);
	  if (res == NULL) {
	      Tcl_SetStringObj (Tcl_GetObjResult (interp), Tcl_GetString (objv[2]), -1);
	      Tcl_AppendResult (interp, " is not a valid query result", NULL);
	      return TCL_ERROR;
	  }

          nFields = PQnfields (res);

	  fieldList = (int *) ckalloc ( nFields * sizeof (int));

	  if (noKeys) {
	      // if called with "-nokeys", there is no default key column
	      keyColumn = -1;
	      firstColumn = 0;
	  } else {
	      // if not called with "-nokeys", the first field in the query
	      // result is the default key column
	      keyColumn = 0;
	      firstColumn = 1;
	  }

	  for (field = firstColumn; field < nFields; field++) {
	      fieldName = PQfname (res, field);

	      Tcl_SetStringObj (fieldNameObj, fieldName, -1);

	      if (Tcl_GetIndexFromObj (interp, fieldNameObj, ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
		  if (nocomplain) {
		      Tcl_ResetResult(interp);
		      fieldIndex = -1;
		  } else {
		      Tcl_AppendResult (interp, " while matching postgres field \"", fieldName, "\" with fields from table \"${table}\"", (char *)NULL);
		      return TCL_ERROR;
		  }
	      }

	      fieldList[field] = fieldIndex;

	      // If any column matches the key, then use it. This means
	      // ignoring the first column if noKeys wasn't set.
	      if(${table}_keyField == fieldIndex) {
	          keyColumn = field;
	      }
	  }

	  nTuples = PQntuples (res);

	  for (pgRow = 0; pgRow < nTuples; pgRow++) {

	      if (poll_interval) {
	          if (++poll_counter >= poll_interval) {
		      poll_counter = 0;
		      if (poll_code) {
		          int result = Tcl_EvalObjEx (interp, poll_code, 0);
			  if (poll_foreground) {
			      switch (result) {
		                  case TCL_ERROR: {
				      Tcl_AppendResult (interp, " in -poll_code", (char *)NULL);
				      return TCL_ERROR;
			          }
			          case TCL_BREAK: {
				      return TCL_OK;
				  }
			          case TCL_RETURN: {
			              return TCL_RETURN;
			          }
			      }
			  } else if(result == TCL_ERROR) {
			      Tcl_BackgroundError(interp);
			      Tcl_ResetResult(interp);
			      // Stop polling if the poll command fails
			      poll_interval = 0;
		          }
		      } else {
		          Tcl_DoOneEvent(0);
		      }
		  }
	      }

	      if(keyColumn == -1) {
	          sprintf (keyNumberString, "%d", ctable->autoRowNumber++);
	          key = keyNumberString;
	      } else {
	          key = PQgetvalue(res, pgRow, keyColumn);
	      }

	      row = ${table}_find_or_create (interp, ctable, key, &indexCtl);
	      if(!row) {
	          Tcl_AppendResult (interp, " while saving Postgres result into ${table}", (char *)NULL);
	          return TCL_ERROR;
	      }

	      for (field = firstColumn; field < nFields; field++) {
		  if(field == keyColumn) {
		      continue;
		  }

		  if(fieldList[field] == -1) {
		      continue;
		  }

	          value = PQgetvalue (res, pgRow, field);

		  if (value == NULL) {
		      if (PQgetisnull (res, pgRow, field)) {
			  if (${table}_set_null (interp, ctable, row, fieldList[field], indexCtl) == TCL_ERROR) {
			      Tcl_AppendResult (interp, " while setting null value for field \"", fieldName, "\" in table \"${table}\"", (char *)NULL);
		              return TCL_ERROR;
			  }
		          continue;
		      }
		      valueObj = ${table}_DefaultEmptyStringObj;
		  } else {
		      Tcl_SetStringObj (utilityObj, value, -1);
		      valueObj = utilityObj;
		  }
		  ${table}_set (interp, ctable, valueObj, row, fieldList[field], indexCtl);
	      }

              if (indexCtl == CTABLE_INDEX_NEW)
	          if (${table}_index_defaults(interp, ctable, row) == TCL_ERROR)
	              return TCL_ERROR;
	  }

	  if (noKeys && key != NULL) {
	      Tcl_SetObjResult (interp, Tcl_NewStringObj (key, -1));
	  }

	  break;
#else
        Tcl_SetStringObj (Tcl_GetObjResult (interp), "this version of ctables was built without postgresql support", -1);
        Tcl_SetErrorCode (interp, "speedtables", "built_without_postgres_support", NULL);
        return TCL_ERROR;
#endif
      }

      case OPT_WRITE_TABSEP:
      case OPT_READ_TABSEP: {
        int             *fieldIds = NULL;
	int              i;
	int              objIdx = 3;
	int              nFields = 0;
	char            *pattern = NULL;
	char            *channel;
	int              noKeys = 0;
	int		 withFieldNames = 0;
	int		 withNulls = 0;
	char		*sepstr = "\t";
	int		 nocomplain = 0;
	char		*skip = NULL;
	char		*term = NULL;
	char	        *nullString = NULL;
	int		 quoteType = CTABLE_QUOTE_NONE;
	int		 poll_interval = 0;
	Tcl_Obj		*poll_code = NULL;
	int		 poll_foreground = 0;

	while (objIdx < objc) {
	    char *possibleSwitch;

	    possibleSwitch = Tcl_GetString(objv[objIdx]);
	    if (*possibleSwitch != '-') break;

	    if (strcmp (possibleSwitch, "-glob") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-glob not followed by pattern", (char *)NULL);
		    return TCL_ERROR;
		}
		pattern = Tcl_GetString (objv[objIdx++]);
	    } else if (strcmp (possibleSwitch, "-tab") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-tab not followed by tab string", (char *)NULL);
		    return TCL_ERROR;
		}
		sepstr = Tcl_GetString (objv[objIdx++]);
	    } else if (strcmp (possibleSwitch, "-null") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-null not followed by null string", (char *)NULL);
		    return TCL_ERROR;
		}
		nullString = Tcl_GetString (objv[objIdx++]);
	    } else if (strcmp (possibleSwitch, "-quote") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-quote not followed by quote type", (char *)NULL);
		    return TCL_ERROR;
		}
	        quoteType = ctable_parseQuoteType(interp, objv[objIdx++]);
	        if(quoteType < 0) {
		    Tcl_AppendResult (interp, "in argument to -quote", NULL);
		    return TCL_ERROR;
	        }
	    } else if (strcmp (possibleSwitch, "-skip") == 0) {
		if(optIndex != OPT_READ_TABSEP) {
		    Tcl_AppendResult (interp, "-skip does not make sense for write_tabsep", (char *)NULL);
		    return TCL_ERROR;
		}
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-skip not followed by pattern", (char *)NULL);
		    return TCL_ERROR;
		}
		skip = Tcl_GetString (objv[objIdx++]);
	    } else if (strcmp (possibleSwitch, "-term") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-term not followed by pattern", (char *)NULL);
		    return TCL_ERROR;
		}
		term = Tcl_GetString (objv[objIdx++]);
	    } else if (strcmp (possibleSwitch, "-nokeys") == 0) {
		objIdx++;
		noKeys = 1;
	    } else if (strcmp (possibleSwitch, "-with_field_names") == 0) {
		objIdx++;
		withFieldNames = 1;
	    } else if (optIndex != OPT_WRITE_TABSEP && strcmp (possibleSwitch, "-with_nulls") == 0) {
		objIdx++;
		withNulls = 1;
	    } else if (optIndex != OPT_WRITE_TABSEP && strcmp (possibleSwitch, "-nocomplain") == 0) {
		objIdx++;
		nocomplain = 1;
	    } else if (optIndex != OPT_WRITE_TABSEP && strcmp (possibleSwitch, "-poll_interval") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-poll_interval not followed by a value", (char *)NULL);
		    return TCL_ERROR;
		}
		if (Tcl_GetIntFromObj(interp, objv[objIdx++], &poll_interval) == TCL_ERROR) {
		    Tcl_AppendResult (interp, "in argument to -poll_interval", NULL);
		    return TCL_ERROR;
		}
	    } else if (optIndex != OPT_WRITE_TABSEP && strcmp (possibleSwitch, "-poll_code") == 0) {
		objIdx++;
	        if (objIdx >= objc) {
		    Tcl_AppendResult (interp, "-poll_code", (char *)NULL);
		    return TCL_ERROR;
		}
		if (poll_interval == 0)
		    poll_interval = CTABLE_DEFAULT_POLL_INTERVAL;
		poll_code = objv[objIdx++];
	    } else if (optIndex != OPT_WRITE_TABSEP && strcmp (possibleSwitch, "-foreground") == 0) {
		objIdx++;
		poll_foreground = 1;
	    } else {
		Tcl_AppendResult (interp, "unknown switch: ", possibleSwitch, (char *)NULL);
		return TCL_ERROR;
	    }
	}

	if (poll_code != NULL && poll_interval == 0) {
	    Tcl_AppendResult (interp, "-poll_code specified but -poll_interval set to 0", NULL);
	    return TCL_ERROR;
	}

	nFields = objc - objIdx;

	if (nFields < 0) {
	  Tcl_WrongNumArgs (interp, 2, objv, "channel ?-glob pattern? ?-nokeys? ?-tab string? ?-with_field_names? ?-skip pattern? ?-term pattern? ?-null string? ?field field...?");
	  return TCL_ERROR;
	}

	if (nFields == 0) {
	    if (optIndex == OPT_WRITE_TABSEP || !withFieldNames) {
		fieldIds = (int *)ckalloc($nFields * sizeof (*fieldIds));
	        for (nFields = i = 0; i < $nFields; i++) {
		    if(!is_hidden_name(${table}_fields,i)) {
	                fieldIds[nFields++] = i;
		    }
	        }
	    }
	} else {
	    if (optIndex != OPT_WRITE_TABSEP && withFieldNames) {
		Tcl_AppendResult(interp, "Can not specify explicit field names when reading with \"-with_field_names\"", (char *)NULL);
		return TCL_ERROR;
	    }
	    fieldIds = (int *)ckalloc(nFields * sizeof(*fieldIds));
	    for (i = 0; i < nFields; i++) {
	        if (Tcl_GetIndexFromObj (interp, objv[objIdx++], ${table}_fields, "field", TCL_EXACT, &fieldIds[i]) != TCL_OK) {
		    if(nocomplain) {
			fieldIds[i] = -1;
		    } else {
			ckfree((void *)fieldIds);
		        return TCL_ERROR;
		    }
		}
	    }
	}

	channel = Tcl_GetString (objv[2]);

#ifdef MANIACDEBUGGER
{
  char buffer[9999];
  char *s=buffer;
  
  if(fieldIds) {
    *s++ = '{';
    for(i = 0; i < nFields; i++) {
      if(i) { *s++ = ','; *s++ = ' '; }
      sprintf(s, "%d", fieldIds[i]);
      s += strlen(s);
    }
    *s++ = '}';
    *s = 0;
  } else {
    sprintf(buffer, "(null)");
  }

  fprintf(stderr,
	"${table}_%s_tabsep (interp, ctable, %s, %s, %d, \"%s\", %d, %d, \"%s\", /%s/, /%s/);\n",
	optIndex == OPT_WRITE_TABSEP ? "export" : "import",
	channel, buffer, nFields, pattern, noKeys, withFieldNames, sepstr, skip, term
  );
}
#endif

	if (optIndex == OPT_WRITE_TABSEP) {
	    commandStatus = ${table}_export_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys, withFieldNames, sepstr, term, quoteType, nullString);
	} else if(optIndex == OPT_READ_TABSEP) {
	    commandStatus = ${table}_import_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys, withFieldNames, sepstr, skip, term, nocomplain, withNulls, quoteType, nullString, poll_interval, poll_code, poll_foreground);
	}

	if(fieldIds) ckfree((void *)fieldIds);

	break;
      }

      case OPT_INDEX: {
	static CONST char *subOptions[] = {"span", "count", "create", "drop", "indexable", "indexed", "unique", "list", "dump", (char *)NULL};
	int                suboptIndex;
	int                fieldNum;

	enum suboptions {SUBOPT_SPAN, SUBOPT_COUNT, SUBOPT_CREATE, SUBOPT_DROP, SUBOPT_INDEXABLE, SUBOPT_INDEXED, SUBOPT_UNIQUE, SUBOPT_LIST, SUBOPT_DUMP};

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "option ?args?");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], subOptions, "suboption", TCL_EXACT, &suboptIndex) != TCL_OK) {
	    return TCL_ERROR;
	}

	switch (suboptIndex) {
	  case SUBOPT_SPAN: {
	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	      }

	      return ctable_LappendIndexLowAndHi (interp, ctable, fieldNum);
	  }

	  case SUBOPT_COUNT: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    return ctable_IndexCount (interp, ctable, fieldNum);
	  }

	  case SUBOPT_CREATE: {
	    int depth = 20;

#ifdef WITH_SHARED_TABLES
	    if(ctable->share_type == CTABLE_SHARED_MASTER && ctable->share) {
	        // Check for free space
	        if(shmfreemem(ctable->share, 0) < ctable->share_min_free) {
		    Tcl_AppendResult (interp, "Free shared memory low.", NULL);
		    Tcl_SetErrorCode (interp, "speedtables", "shared_memory_low", NULL);
		    return TCL_ERROR;
	        }
	    }
#endif

	    if ((objc < 4) || (objc > 5)) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName ?depth?");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (objc == 5) {
	        if (Tcl_GetIntFromObj (interp, objv[4], &depth) == TCL_ERROR) {
		    return TCL_ERROR;
		}
	    }

	    if (ctable_CreateIndex (interp, ctable, fieldNum, depth) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_DROP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    ctable_DropIndex (ctable, fieldNum, 0);
	    break;
	  }

	  case SUBOPT_INDEXABLE: {
	      int field;

	      // for each field, if the index number in the creator table's
	      // per-field structure is >= 0 then lappend the field name
	      // to the Tcl result object

	      for (field = 0; field < ctable->creator->nFields; field++) {
	          ctable_FieldInfo *f = ctable->creator->fields[field];

		  if (f->indexNumber >= 0) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), f->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_INDEXED: {
	      int field;

	      // for each field if the skipList pointer for that table is
	      // non-null, lappend the field name

	      for (field = 0; field < ctable->creator->nFields; field++) {
	          if (ctable->skipLists[field] != NULL) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ctable->creator->fields[field]->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_UNIQUE: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), ctable->creator->fields[fieldNum]->unique);
	    return TCL_OK;
	  }

	  case SUBOPT_DUMP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_DumpIndex (ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_LIST: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_ListIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }
	}

	break;
      }

      case OPT_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp, ${table}_genlist (interp, row));
	    break;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_fieldobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET_WITH_NULLS: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    break;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_keyvalue_list (interp, row));
	    break;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    break;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_nonnull_keyvalue_list (interp, row));
	    break;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_nonnull_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_FOREACH: {
	  ctable_HashSearch  hashSearch;
	  char              *pattern = (char *) NULL;
	  char              *key;
	  int                codeIndex = 3;

	  if ((objc < 4) || (objc > 5)) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName ?pattern? codeBody");
	      return TCL_ERROR;
	  }

	  if (objc == 5) {
	      pattern = Tcl_GetString (objv[3]);
	      codeIndex = 4;
	  }

	  for (hashEntry = ctable_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (ctable_HashEntry *) NULL; hashEntry = ctable_NextHashEntry (&hashSearch)) {
	      key = hashEntry->key;
	      if ((pattern != (char *) NULL) && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ObjSetVar2 (interp, objv[2], (Tcl_Obj *)NULL, Tcl_NewStringObj (key, -1), TCL_LEAVE_ERR_MSG) == (Tcl_Obj *) NULL) {
	          return TCL_ERROR;
	      }
	      switch (Tcl_EvalObjEx (interp, objv[codeIndex], 0)) {
	        case TCL_ERROR:
		  Tcl_AddErrorInfo (interp, "\n    while processing foreach code body");
		  return TCL_ERROR;

		case TCL_OK:
		case TCL_CONTINUE:
		  break;

		case TCL_BREAK:
		  return TCL_OK;

		case TCL_RETURN:
		  return TCL_RETURN;
	      }
	  }
	  break;
      }

      case OPT_NULL: {
	int            i;
	int            field;
        struct $table *row;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    Tcl_AppendResult (interp, "no such key");
	    return TCL_ERROR;
	}

	if(objc == 3) {
	    Tcl_Obj *result = Tcl_NewObj();

	    for(i = 0; i < $nFields; i++) {
		if(${table}_is_null(row, i)) {
		    if(Tcl_ListObjAppendElement(interp, result, ${table}_NameObjList[i]) == TCL_ERROR) {
			return TCL_ERROR;
		    }
		}
	    }

	    Tcl_SetObjResult(interp, result);
	    return TCL_OK;
	}

	for(i = 3; i < objc; i++) {
	    if (Tcl_GetIndexFromObj (interp, objv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if(${table}_set_null(interp, ctable, row, field, CTABLE_INDEX_NORMAL) != TCL_OK) {
		return TCL_ERROR;
	    }
	}
	return TCL_OK;
      }

      case OPT_ISNULL: {
	int            i;
	int            field;
        struct $table *row;
	Tcl_Obj       *result = Tcl_NewObj();

	if (objc < 4) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key field ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    Tcl_AppendResult (interp, "no such key");
	    return TCL_ERROR;
	}

	for(i = 3; i < objc; i++) {
	    if (Tcl_GetIndexFromObj (interp, objv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if(Tcl_ListObjAppendElement(interp, result, Tcl_NewIntObj(${table}_is_null(row, field))) != TCL_OK) {
		return TCL_ERROR;
	    }
	}

	Tcl_SetObjResult(interp, result);
	return TCL_OK;
      }

      case OPT_VERIFY: {
        int verbose = 0;

	if (objc > 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "?-verbose?");
	    return TCL_ERROR;
	}
	if (objc >= 3) {
	    char *opt = Tcl_GetString(objv[2]);
	    if (strcmp (opt, "-verbose") != 0) {
		Tcl_AppendResult (interp, "option must be '-verbose'", (char *)NULL);
		return TCL_ERROR;
	    }
	    verbose = 1;
	}

        ctable_verify(interp, ctable, verbose);
	return TCL_OK;
      }
    }

#ifdef WITH_SHARED_TABLES
    end_write(ctable);
#endif
    return commandStatus;
}

